<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kaizeiとyimi</title>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2016-04-17T03:34:24.000Z</updated>
  <id>/</id>
  
  <author>
    <name>kaizei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>make AutoLayout X</title>
    <link href="/2016/04/17/make-AutoLayout-X/"/>
    <id>/2016/04/17/make-AutoLayout-X/</id>
    <published>2016-04-17T03:34:24.000Z</published>
    <updated>2016-04-17T03:34:24.000Z</updated>
    
    <content type="html">&lt;p&gt;其实挺不好意思的, 2年前的知识, 半年前的库, 现在才写下来. sigh...&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;陈年旧事&quot;&gt;&lt;a href=&quot;#陈年旧事&quot; class=&quot;headerlink&quot; title=&quot;陈年旧事&quot;&gt;&lt;/a&gt;陈年旧事&lt;/h2&gt;&lt;p&gt;以前我吐槽了约束写起来太费劲, 布局很手动化, 几乎需要非常详细地指明每一个约束的每一个条件. 而这样的结果就是代码非常长, 阅读和理解都好困难, 看着打瞌睡. VFL? no kidding me again. &lt;/p&gt;
&lt;p&gt;反正好麻烦, 然后开源社区出现了一个库&lt;strong&gt;Masonry&lt;/strong&gt;, 目的是简化代码写约束, 提供了链式语法以及一些helper方法. 当然本文不是要介绍它, 也不是要批评它, 只是吐槽而已, 后文再说. 本文主要是介绍我写的&lt;strong&gt;XAutoLayout&lt;/strong&gt;😃. &lt;/p&gt;
&lt;h2 id=&quot;demo-code&quot;&gt;&lt;a href=&quot;#demo-code&quot; class=&quot;headerlink&quot; title=&quot;demo code&quot;&gt;&lt;/a&gt;demo code&lt;/h2&gt;&lt;p&gt;使用起来还是比较方便的. 我定义了几个操作符&lt;code&gt;=/&lt;/code&gt;,&lt;code&gt;&amp;lt;=/&lt;/code&gt;和&lt;code&gt;&amp;gt;=/&lt;/code&gt;, 分别与&lt;strong&gt;Equal&lt;/strong&gt;, &lt;strong&gt;lessOrEqual&lt;/strong&gt;, &lt;strong&gt;greaterOrEqual&lt;/strong&gt;这几个方法等价, array仅支持&lt;code&gt;=/&lt;/code&gt;, 对应的方法是&lt;code&gt;compositeEqual&lt;/code&gt; 内部实现都没有使用重载的操作符.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;xmakeConstraints(.&lt;span class=&quot;hljs-type&quot;&gt;RightToLeft&lt;/span&gt;, autoActive = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;) {  &lt;span class=&quot;hljs-comment&quot;&gt;// autoActive has a default value true&lt;/span&gt;
    v1.xEdge =/ [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,-&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,-&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// can directly use number, the second view will be superview&lt;/span&gt;
    v2.xSize =/ [&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;, view.heightAnchor.&lt;span class=&quot;hljs-built_in&quot;&gt;c&lt;/span&gt;(-&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;)] &lt;span class=&quot;hljs-comment&quot;&gt;// can use iOS9 API&lt;/span&gt;

    &lt;span class=&quot;hljs-comment&quot;&gt;// [v2.xTop, v2.xLeading] =/ [20, 10]  same as the below two lines&lt;/span&gt;
    v2.xTop =/ &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;
    v2.xLeading =/ &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;面向接口编程&quot;&gt;&lt;a href=&quot;#面向接口编程&quot; class=&quot;headerlink&quot; title=&quot;面向接口编程&quot;&gt;&lt;/a&gt;面向接口编程&lt;/h2&gt;&lt;p&gt;这个应该是swift最强调的了. 面向接口编程是大家都懂, 但又一般不这么干的一个编程准则. swift2以后给protocol加上了extension提供默认实现的能力, 让面向接口编程更加强大. 加上对之前写过的那个库不满意, 于是决定充分利用语言能力用纯swift重写一个. &lt;/p&gt;
&lt;p&gt;iOS9新增了一些&lt;code&gt;topAnchor&lt;/code&gt;这样的API, 用来封装&lt;code&gt;item&lt;/code&gt;和&lt;code&gt;attr&lt;/code&gt;, 用起来比以前直观一些. 但是现在市面上更多的是base到iOS7, 有些是到iOS8, 这样的API就只能远观了. 虽然方便了一些, 但是因为这些东西还要考虑OC, 导致实际使用时看起来仍然比较冗长.&lt;/p&gt;
&lt;h4 id=&quot;想法的建立&quot;&gt;&lt;a href=&quot;#想法的建立&quot; class=&quot;headerlink&quot; title=&quot;想法的建立&quot;&gt;&lt;/a&gt;想法的建立&lt;/h4&gt;&lt;p&gt;一个约束到底要表达什么? 文档中的等式是这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;first&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;attr&lt;/span&gt; = second.&lt;span class=&quot;hljs-built_in&quot;&gt;attr&lt;/span&gt; * m + c&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以这样去拆分:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;firstItem, firstAttribute&lt;/li&gt;
&lt;li&gt;secondItem, secondAttribute&lt;/li&gt;
&lt;li&gt;relation &lt;/li&gt;
&lt;li&gt;multiplier &amp;amp; constant &amp;amp; priority&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于倍数,偏移量和优先级都默认的情况可以这样书写:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;  &lt;span class=&quot;hljs-selector-tag&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.attr&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.relation&lt;/span&gt;(&lt;span class=&quot;hljs-selector-tag&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.attr&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要配置上述4里面的内容怎么书写呢? 有两种想法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// first type&lt;/span&gt;
  &lt;span class=&quot;hljs-built_in&quot;&gt;first&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;attr&lt;/span&gt;.relation(second.&lt;span class=&quot;hljs-built_in&quot;&gt;attr&lt;/span&gt;).m(&lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;).c(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;).p(&lt;span class=&quot;hljs-number&quot;&gt;750&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样写看起来不错. 但是有两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链式表达式导致最终返回的仍然是一个我们自定义的对象, 想要拿到&lt;code&gt;NSLayoutConstraint&lt;/code&gt;对象还需要再&lt;code&gt;.constraint&lt;/code&gt;一下.&lt;/li&gt;
&lt;li&gt;对复合类型不友好. 就是demo中看到的对Array使用&lt;code&gt;=/&lt;/code&gt;的情况. 两个array是zip起来后遍历创建约束, 这时候只有两个参数, 不好配置m, c, p.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此就变通了一下书写方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// second type&lt;/span&gt;
  first&lt;span class=&quot;hljs-selector-class&quot;&gt;.attr&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.relation&lt;/span&gt;(second&lt;span class=&quot;hljs-selector-class&quot;&gt;.attr&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.m&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;).c(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;).p(&lt;span class=&quot;hljs-number&quot;&gt;750&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是把第4项的m, c, p 和 第二项的item和attribute结合在一起. 这样就演变成了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;A&lt;/span&gt; relation B&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里又有两种做法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A和B分别是两个类型, A可以做左值和右值, B只做右值. 毕竟B带着m, c, p去做左值确实不太好. 但是这样就有个问题, 想要支持直接用数字配置的时候, B怎么表达? 用AnyObject么? &lt;/li&gt;
&lt;li&gt;A和B分别是两个protocol, 这样避免了AnyObject的问题, 并且能对参数进行约束. 加上swift也是可以给已有类型写extension的, 所以用protocol抽象比较好, 参数不用是AnyObject那么宽泛.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;接口的规划&quot;&gt;&lt;a href=&quot;#接口的规划&quot; class=&quot;headerlink&quot; title=&quot;接口的规划&quot;&gt;&lt;/a&gt;接口的规划&lt;/h4&gt;&lt;p&gt;&lt;code&gt;RelationMakeable&lt;/code&gt;和&lt;code&gt;AttributeContainer&lt;/code&gt;就分别是A和B, 并且A继承B. &lt;code&gt;RelationMakeable&lt;/code&gt;有equal, lessOrEqual 和 greatOrEqual方法. &lt;code&gt;AttributeContainer&lt;/code&gt;有 m, c, p的方法, 并且有一个&lt;code&gt;generateX&lt;/code&gt;方法来生成一个真正保存信息的数据&lt;code&gt;XAttributeX&lt;/code&gt;来参与生成约束. &lt;/p&gt;
&lt;p&gt;调用m, c, p, 以及建立关系的行为可以用protocol默认实现来简化其他类型的extension. 这样一个类型仅需声明一下extension, 再添加&lt;code&gt;generateX&lt;/code&gt;方法就可以加入这个体系了, 比如iOS提供的&lt;code&gt;NSLayoutAnchor&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@available&lt;/span&gt;(iOS &lt;span class=&quot;hljs-number&quot;&gt;9.0&lt;/span&gt;, *)
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NSLayoutAnchor&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;RelationMakeable&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;generateX&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttributeX&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; item = valueForKey(&lt;span class=&quot;hljs-string&quot;&gt;&quot;item&quot;&lt;/span&gt;)!
        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; attr = &lt;span class=&quot;hljs-type&quot;&gt;NSLayoutAttribute&lt;/span&gt;(rawValue: valueForKey(&lt;span class=&quot;hljs-string&quot;&gt;&quot;attr&quot;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt;! &lt;span class=&quot;hljs-type&quot;&gt;Int&lt;/span&gt;)!
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttributeX&lt;/span&gt;(item: item, attr: attr)
    }
}

v1.xTop =/ v2.bottomAnchor.&lt;span class=&quot;hljs-built_in&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后UIView这样的主角需要的是一些property来表达&lt;code&gt;item + attr&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;UIView&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xLeft: &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Left&lt;/span&gt;) }
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xRight: &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Right&lt;/span&gt;) }
    ... some more
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后&lt;code&gt;UILayoutSupport&lt;/code&gt;也可以轻松加入:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;UILayoutSupport&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xTop: &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Top&lt;/span&gt;) }
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xBottom: &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Bottom&lt;/span&gt;) }
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xHeight: &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Height&lt;/span&gt;) }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为一开始就考虑了要支持Array, 所以给UIView也加上了几个复合属性:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;UIView&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xSize: [&lt;span class=&quot;hljs-type&quot;&gt;RelationMakeable&lt;/span&gt;] {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [xWidth, xHeight]
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xCenter: [&lt;span class=&quot;hljs-type&quot;&gt;RelationMakeable&lt;/span&gt;] {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [xCenterX, xCenterY]
    }
    ... some more
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但其实可以随意组合, 比如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;[v.xTop,v.xLeading] =/ [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;array里面也能写nil, 表达这个位置不进行配置, 比如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;v.xEdge =/ [&lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] 
v.xHeight =/ &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就表达了左下右三边紧贴父view, top不配置. 然后再给v设置高度为200.&lt;/p&gt;
&lt;h2 id=&quot;嵌套书写&quot;&gt;&lt;a href=&quot;#嵌套书写&quot; class=&quot;headerlink&quot; title=&quot;嵌套书写&quot;&gt;&lt;/a&gt;嵌套书写&lt;/h2&gt;&lt;p&gt;用&lt;code&gt;xmakeConstraint&lt;/code&gt;创建约束时, 创建的语句是写在闭包里面, 并且还可以控制布局方向和是否自动激活. 也就是说闭包里面的约束是同一组, 接受同样的配置. but how? &lt;/p&gt;
&lt;p&gt;挠挠头, 因为创建约束的过程是内部控制, 我能准确地知道创建的时机, 因此我创建了一个私有上下文对象, 记录一组约束的配置信息, 闭包里面的约束都在这个上下文内根据方向去创建, 并决定是否直接激活. &lt;/p&gt;
&lt;p&gt;因为闭包里面还可以继续嵌套调用&lt;code&gt;xmakeConstraint&lt;/code&gt;, 因此, 上下文需要做成栈, 每一次调用就push一个新的上下文, 调用结束就pop掉.&lt;/p&gt;
&lt;p&gt;系统创建的约束默认是不激活的, 因此, 栈里面默认有一个方向是&lt;strong&gt;LeadingToTrailing&lt;/strong&gt;, 默认不自动激活的上下文. 不在&lt;code&gt;xmakeConstraint&lt;/code&gt;的闭包里, 而是直接裸写的约束才会使用这个上下文. 但这样带来一个小问题, 如果在闭包中调用了一个方法, 方法内部有裸写的约束, 则其实这些看起来裸写的约束也还是处在同一个上下文中. 因此最好都调用&lt;code&gt;xmakeConstraint&lt;/code&gt;来写约束. &lt;/p&gt;
&lt;h2 id=&quot;方向&quot;&gt;&lt;a href=&quot;#方向&quot; class=&quot;headerlink&quot; title=&quot;方向&quot;&gt;&lt;/a&gt;方向&lt;/h2&gt;&lt;p&gt;人类的语言有从左到右, 从右到左, 竖直方向还好都是从上到下. 所以苹果给了3个方向的选择: 分别是LeadingToTrailing, LeftToRight和RightToLeft, 表达是否由系统语言来决定布局方向. 这个参数是在VFL中使用, 而非VFL中是没法使用的. &lt;/p&gt;
&lt;h4 id=&quot;存在的问题-1&quot;&gt;&lt;a href=&quot;#存在的问题-1&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;&gt;&lt;/a&gt;存在的问题&lt;/h4&gt;&lt;p&gt;提到方向就不得不多聊几句. VFL里面指定方向为明确的左到右或者右到左时, 创建出来的约束中, Leading和Trailing会根据方向被直接转换为&lt;strong&gt;Left&lt;/strong&gt;或者&lt;strong&gt;Right&lt;/strong&gt;. 还有一个小问题, 虽然转换了方向, 在计算坐标时仍然是从左向右, 从上到下. 平时使用时一般倍数都是1, 所以不会有啥影响, 只有倍数不为1时才有点儿秀逗. 主要原因是位置计算发生在firstItem和secondItem的最低公共父view的坐标系中, 层级关系不同可能导致参照系不同, 接着导致计算倍数时的基准值不同. 不过一般不建议给位置这样的attribute设置倍数, 否则结果可能完全不是你想象的.&lt;/p&gt;
&lt;p&gt;还有一个变化是iOS9中对水平方向的attribute做了限制. 看一下exception的信息:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; constraint cannot be made between a leading/trailing attribute and a right/left attribute. Use leading/trailing for both or neither.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也正如它所说, 只check水平方向的, 要么都是leading/trailing, 要么都是left/right. 如果是leading和top之类的它就不管... 不过讲真, 拿水平方向和垂直方向的位置属性做约束还是有点儿那啥...&lt;/p&gt;
&lt;h4 id=&quot;属性转换&quot;&gt;&lt;a href=&quot;#属性转换&quot; class=&quot;headerlink&quot; title=&quot;属性转换&quot;&gt;&lt;/a&gt;属性转换&lt;/h4&gt;&lt;p&gt;&lt;code&gt;xmakeConstraint&lt;/code&gt;方法有direction参数, 表达这一组约束的方向信息. 什么时候生效呢? 遵循VFL的做法, 仅当方向不为&lt;strong&gt;LeadingToTrailing&lt;/strong&gt;并且attribute是Leading或者Trailing时才会将attribute转换为Left或者Right.&lt;/p&gt;
&lt;p&gt;当然也不是遇到就转换, 条件还是有的. 再看看系统可能的行为: VFL可以指定方向, 但是受影响的约束的两个attribute肯定是水平方向的Leading/Trailing. 不用VFL时, 可以随意一些, 水平方向的属性可以和垂直方向的或者center等做约束. 也就是不用都是水平方向的属性. 同时iOS针对了少量的几种不配对情况抛出异常.&lt;/p&gt;
&lt;p&gt;为了最大程度和系统行为一致, 创建约束时要先检查attribute是否能配对, lib里面主动抛出的异常就一个, 就是方向不为LeadingToTrailing并且只有一个属性是leading/trailing, 另一个不是水平方向属性. 这种情况下我不知道该不该转换, 而且这种情况用原生API是构造不出来的. 其他不配对的情况lib不处理, 留给iOS来让抛异常提醒你吧.&lt;/p&gt;
&lt;p&gt;如果配对检查过了, 受RightToLeft方向影响的约束需要把constant 乘 -1. &lt;/p&gt;
&lt;h2 id=&quot;扩展数字类型&quot;&gt;&lt;a href=&quot;#扩展数字类型&quot; class=&quot;headerlink&quot; title=&quot;扩展数字类型&quot;&gt;&lt;/a&gt;扩展数字类型&lt;/h2&gt;&lt;p&gt;为了方便, 在设置位置类型的属性时, 可以直接设置数字, 这样secondItem就默认是firstItem的superView, 只要firstItem是一个UIview的话. 这就意味着数字也是&lt;code&gt;AttributeContainer&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;swift里面有很多种数字类型, 我不得不对每一种都声明extension. 声明一个extension就需要写一次&lt;code&gt;generateX&lt;/code&gt;方法, 看起来好繁琐. 于是沿着这些数字实现的协议链往上找, 最终选择了扩展&lt;code&gt;SignedNumberType&lt;/code&gt; 和 &lt;code&gt;UnsignedIntegerType&lt;/code&gt;来实现&lt;code&gt;generateX&lt;/code&gt;. 这样所有的数字类型就都有了&lt;code&gt;generateX&lt;/code&gt;实现. &lt;/p&gt;
&lt;h2 id=&quot;吐槽Masonry&quot;&gt;&lt;a href=&quot;#吐槽Masonry&quot; class=&quot;headerlink&quot; title=&quot;吐槽Masonry&quot;&gt;&lt;/a&gt;吐槽Masonry&lt;/h2&gt;&lt;p&gt;说实话, 第一次看这个库就觉得做复杂了. 而且一些想法挺奇怪的, 代码中还有一些欠考虑的地方, 分分钟出bug.&lt;/p&gt;
&lt;p&gt;它创建约束的分组想法和我不一样, 它是针对每个view去写一组这个view作为firstItem的约束, 并且制约了裸写约束的可能性, 这样的好处是不用care嵌套的问题, 但是会导致书写的闭包很多.&lt;/p&gt;
&lt;p&gt;它有个&lt;code&gt;MASLayoutConstraint&lt;/code&gt;的类继承自&lt;code&gt;NSLayoutConstraint&lt;/code&gt;,  make时生成的约束全都是这个子类. update和remake方法都只跟自己的体系玩儿, 这些操作只认这个类, 也就是说除非你关于这个view的所有约束都是用Masonry做, 否则update和remake方法没用. 对于有用到storyboard而只想用一个lib来简化部分约束编写的人来说, 只有make那个方法敢用. &lt;/p&gt;
&lt;p&gt;update这个方法会去查询&lt;strong&gt;相似&lt;/strong&gt;的约束, 然后更新这个相似约束的constant而不是激活新的约束. 看Masonry的逻辑, 它把这个概念定义为除了constant以外其他属性全都相同的两个约束是相似的. 但是在AutoLayout里面根本就没有相似这个概念, 所以我觉得不应该生造出这么个概念. 而且约束是双向影响, 下面的两个约束是完全等价的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;v1.xTop =/ v2.xBottom.&lt;span class=&quot;hljs-built_in&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)
v2.xBottom =/ v1.xTop(-&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这在Masonry里面却会被判定为&lt;strong&gt;不相似&lt;/strong&gt;的约束.&lt;/p&gt;
&lt;p&gt; 它的ReadMe里面有这么一句话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Alternatively if you are only updating the constant value of the constraint you can use the convience method mas_updateConstraints instead of mas_makeConstraints.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际状况是, 如果在一个地方创建, 在另一个地方update, 这两处的first和second必须写得一样才行. 否则哪怕我只是更新constant, 就会因为约束用了另一个等价形式就会激活新的约束与旧的并存. 一般情况下这样都会导致约束冲突, 如果不能自动解决就crash了, 但不管怎样都不是开发者想看到的.&lt;/p&gt;
&lt;p&gt;而且查找相似这个工作本来应该是要递归到window去的, 因为约束不是必须放在最低公共父view上. 不知道是不是因为考虑到了这个效率问题, 才决定只跟自己玩儿, 自己创建的约束, 自己找最低公共父view来激活, 记录下installed view, 然后更新的时候只在这个view上找相似.&lt;/p&gt;
&lt;p&gt;remake方法是删掉有这个view参与的约束然后激活闭包里的约束. 实际使用起来会非常掣肘. 原因主要也是因为Masonry只跟自己玩儿.&lt;/p&gt;
&lt;p&gt;Masonry为了能够支持各个类型的参数, 弄了一个&lt;code&gt;_MASBoxValue&lt;/code&gt;的宏, 利用encoding来对值进行包装并返回id类型. 还用了黑魔法来改变建立关系的方法. 有人觉得挺牛逼的, 我觉得挺不好的. 见仁见智?&lt;/p&gt;
&lt;p&gt;然后对于复合属性的支持也不怎么友好, 内部实现中弄了个delegate来把一个复合变成多个约束, 真心太复杂了. &lt;/p&gt;
&lt;p&gt;总之是觉得Masonry想的太多, 做得不好. 不过有些思路还是可以借鉴的, 比如利用编译器接受无参数有返回值的方法当readonly的property的getter调用这个tricky的地方, 用圆括号和&lt;code&gt;.&lt;/code&gt;实现了链式调用语法.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// no property named test&lt;/span&gt;
-(BlockType)test;

&lt;span class=&quot;hljs-comment&quot;&gt;// can be called like readonly property&lt;/span&gt;
xxx.test();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BlockType如果有参数和返回值, 这个&lt;code&gt;.()&lt;/code&gt;调用的操作就能继续下去. 不过依赖这种编译器的tricky特性总觉得不安全.&lt;/p&gt;
&lt;p&gt;仍然只支持iOS7, 导致不能用8才有的active属性来激活约束. 不过看Masonry的实现, 体系里面对最低公共父view依赖比较多, 就算到8也省不了多少代码.&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;&lt;a href=&quot;#写在最后&quot; class=&quot;headerlink&quot; title=&quot;写在最后&quot;&gt;&lt;/a&gt;写在最后&lt;/h2&gt;&lt;p&gt;我的想法也不一定对, 不一定好. 我只是客观地分析了Masonry, 吐槽不对的地方还请看客谅解. 我自己的库也不一定很好用, 虽然我自己一直在用~ &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实挺不好意思的, 2年前的知识, 半年前的库, 现在才写下来. sigh...&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="swift" scheme="/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>改用hexo了!</title>
    <link href="/2016/04/13/%E6%94%B9%E7%94%A8hexo%E4%BA%86/"/>
    <id>/2016/04/13/改用hexo了/</id>
    <published>2016-04-13T13:12:36.000Z</published>
    <updated>2016-04-14T12:23:40.000Z</updated>
    
    <content type="html">&lt;p&gt;思量再三, 还是不用jekyll了. Ruby什么的累觉不爱, 最关键的是我刚装上最新版就直接不能启动... &lt;/p&gt;
&lt;p&gt;什么? &lt;span style=&quot;color:rgb(179,62,170)&quot;&gt;&lt;strong&gt;没有给空定义match方法&lt;/strong&gt;&lt;/span&gt;. 喂, 还能再详细点儿么? 让我怎么排查问题?&lt;/p&gt;
&lt;p&gt;正好听朋友说&lt;strong&gt;hexo&lt;/strong&gt;, 去䁖了一眼, 用Node做的. 文档真的是...(省略吐槽无数). 擦擦嘴, 喝口水. 其实做得挺不错的, 除了默认主题有点儿丑外加文档很烂以外. &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;折腾了几天, 基于一个主题&lt;a href=&quot;https://github.com/pagecho/maupassant&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;maupassant&lt;/a&gt;进行了不少修改, 删除了大量我不需要的功能, 然后大改css, markdown解析以及高亮. 最后除了页面结构差不多, 其他的都差很多.&lt;/p&gt;
&lt;p&gt;我这也算是自己弄了个主题? &lt;/p&gt;
&lt;p&gt;我觉得hexo不错也许是因为我没有发现jekyll好用. 反正我暂时不会用jekyll了. 刚开始down下来默认模板的时候, 看了一下package, 带了一些category, tag之类的生成器, 一个markdown解析器用的marked, 然后还有个sass解析器的样子. 高亮是用的&lt;strong&gt;highlight.js&lt;/strong&gt;, 这个已经被hexo内置了.&lt;/p&gt;
&lt;h2 id=&quot;其实我还是要吐槽的&quot;&gt;&lt;a href=&quot;#其实我还是要吐槽的&quot; class=&quot;headerlink&quot; title=&quot;其实我还是要吐槽的!!&quot;&gt;&lt;/a&gt;其实我还是要吐槽的!!&lt;/h2&gt;&lt;p&gt;不过槽点并不是很多, 嗯.&lt;/p&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;&lt;a href=&quot;#配置文件&quot; class=&quot;headerlink&quot; title=&quot;配置文件&quot;&gt;&lt;/a&gt;配置文件&lt;/h3&gt;&lt;p&gt;其实我很喜欢&lt;code&gt;gulp&lt;/code&gt;的想法. 扔掉键值对的配置文件, 直接用代码来配置. hexo完全基于Node, 所以为什么不直接用代码来配置? 讲真, 翻看源码的时候看到了一个用代码写好的default config的Object, hexo的逻辑是先加载default config, 然后加载我们的yml写的config文件去覆盖. 真的, 让我们直接写js吧, 最后吐出一个Object就行了, 这样就能完美解决插件配置的问题.&lt;/p&gt;
&lt;h3 id=&quot;marked&quot;&gt;&lt;a href=&quot;#marked&quot; class=&quot;headerlink&quot; title=&quot;marked&quot;&gt;&lt;/a&gt;marked&lt;/h3&gt;&lt;p&gt;首先是markdown解析. 好吧, 本来用marked挺好, 可是呢, marked需要配置啊, 默认的行为当然不是我想要的, 我需要修改它对head, table, code等的解析. 但是这些修改需要修改renderer的方法, 很显然, 这需要code. marked插件的源码我也读了一下, 它会去config对象上获取非常简单的能够用键值对配置的信息, 对于修改renderer无能为力. 因为hexo的做法直接屏蔽了这种可能性.&lt;/p&gt;
&lt;p&gt;于是, 我自己写了插件... sigh. 没有做成npm包的形式, 而是直接在&lt;code&gt;scripts&lt;/code&gt;文件夹里面写了一个简单的js. hexo说这里的脚本会在hexo启动的时候执行.&lt;/p&gt;
&lt;h3 id=&quot;highlight-js&quot;&gt;&lt;a href=&quot;#highlight-js&quot; class=&quot;headerlink&quot; title=&quot;highlight.js&quot;&gt;&lt;/a&gt;highlight.js&lt;/h3&gt;&lt;p&gt;真是欲哭无泪, 没有你这么内置的!! 我都只能用非常规手段去require人家原始的包了. hexo内置后, 也只能配置非常少的高亮信息, 对于需要代码配置的仍然只能干瞪眼. 于是, 我禁掉了配置文件里面的高亮, 在我的简单的小脚本里面(是的, 还是那里)在marked解析code时就把高亮了一起解析了. 于是, 页面终于能够正常处理markdown了.&lt;/p&gt;
&lt;h3 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h3&gt;&lt;p&gt;我... 提起这个我无语凝噎. 这缓存做得, 真是绝了. 反正我又写了个小脚本在hexo要处理文件的时候删这个缓存, 这次没有放在主题里面而是放在hexo主目录里面, 因为我觉得有一天应该会处理掉这个问题, 这个小脚本不应该是主题的一部分.&lt;/p&gt;
&lt;p&gt;当时是这样的. 写了一点儿内容, 改了点儿css的我兴冲冲地调用了一把&lt;code&gt;hexo s -l&lt;/code&gt;. oh, yeah! 页面! 然后我又改了一点儿内容, 刷新. 刷新? 刷新??? 为毛线没有变呢? 看日志是有请求的. 于是我重新启动了server, 还是没变!! 什么情况, 不明真相的我看了看文档, 说有缓存, 删掉试试? 然后就好了. 过了一会儿我再改, 又不给力了. 真的是很无奈, 我并没觉得那个缓存有什么帮助, 删! &lt;/p&gt;
&lt;h2 id=&quot;休息一下-吃根香蕉&quot;&gt;&lt;a href=&quot;#休息一下-吃根香蕉&quot; class=&quot;headerlink&quot; title=&quot;休息一下, 吃根香蕉&quot;&gt;&lt;/a&gt;休息一下, 吃根香蕉&lt;/h2&gt;&lt;p&gt;hexo是个Node的程序, 那就意味着Node的辣么多包都是可以搞起的, 虽然我不会. 看起来hexo的架构设计得还不错, 没有仔细研究, 它大概是把事情分成了好几部, 处理文件, 渲染post, 生成各个页面等, 还有filter神马的没仔细看. 每个步骤都可以充分发挥你的想象去做事情, 只要符合规范就好. 而且它可以很好地发挥Node的异步特性, 让页面并行生成.&lt;/p&gt;
&lt;p&gt;目前我的模板是用的jade, css用的scss来写, post当然是markdown啦.&lt;/p&gt;
&lt;p&gt;我的侧边栏和原版的不一样哦, 不会滚出屏幕哦, 不会看到文章后边的时候觉得页面空空的, 也不是单纯的吸顶, 要考虑内容长过窗口高度的情况. 反正是费了点儿功夫, 代码很简单, 也已经把这个做成了一个可开关的功能.&lt;/p&gt;
&lt;p&gt;分享的那个小弹窗觉得原版做得不合理, 于是也改了一下, 布局方式改了, 并且把里面的项目做成了可配置. 其他还有不少改动主要是改进一下布局方式和删了不少代码.&lt;/p&gt;
&lt;h2 id=&quot;总之&quot;&gt;&lt;a href=&quot;#总之&quot; class=&quot;headerlink&quot; title=&quot;总之&quot;&gt;&lt;/a&gt;总之&lt;/h2&gt;&lt;p&gt;我觉得一定是我没有弄明白人家的牛逼之处, 还吐这么多槽, 笨死了🙁.&lt;/p&gt;
&lt;p&gt;其实不就是个静态博客系统么?! 可是折腾的天性加上Node让我很很看好hexo, 是不是&lt;strong&gt;github page&lt;/strong&gt;也支持一下hexo? 哈哈, 这样我就不用每次都要先generate再提交了. 大家也来用一下哇~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;思量再三, 还是不用jekyll了. Ruby什么的累觉不爱, 最关键的是我刚装上最新版就直接不能启动... &lt;/p&gt;
&lt;p&gt;什么? &lt;span style=&quot;color:rgb(179,62,170)&quot;&gt;&lt;strong&gt;没有给空定义match方法&lt;/strong&gt;&lt;/span&gt;. 喂, 还能再详细点儿么? 让我怎么排查问题?&lt;/p&gt;
&lt;p&gt;正好听朋友说&lt;strong&gt;hexo&lt;/strong&gt;, 去䁖了一眼, 用Node做的. 文档真的是...(省略吐槽无数). 擦擦嘴, 喝口水. 其实做得挺不错的, 除了默认主题有点儿丑外加文档很烂以外. &lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>swift AnyObject little tips</title>
    <link href="/2016/04/13/swift-AnyObject-little-tips/"/>
    <id>/2016/04/13/swift-AnyObject-little-tips/</id>
    <published>2016-04-13T02:44:37.000Z</published>
    <updated>2016-04-13T13:09:30.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;AnyObject&lt;/code&gt;在swift里面比较特别. 它是所有类都隐式实现的一个&lt;code&gt;protocol&lt;/code&gt;. Apple的注释里面写着当被用作一个具体类型时, 
所有&lt;code&gt;@objc&lt;/code&gt;的方法和属性都被编译器认为可以访问, 并且都被标记为隐式解包类型. &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;The protocol to which all classes implicitly conform.&lt;/p&gt;
&lt;p&gt;When used as a concrete type, all known &lt;strong&gt;@objc&lt;/strong&gt; methods and
 properties are available, as implicitly-unwrapped-optional methods
 and properties respectively, on each instance of &lt;strong&gt;AnyObject&lt;/strong&gt;. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此, 在强类型中就混入了弱类型的不安定因素.&lt;/p&gt;
&lt;h2 id=&quot;Property&quot;&gt;&lt;a href=&quot;#Property&quot; class=&quot;headerlink&quot; title=&quot;Property&quot;&gt;&lt;/a&gt;Property&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; value: &lt;span class=&quot;hljs-type&quot;&gt;AnyObject&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; frame = value.frame&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;value&lt;/code&gt;其实是&lt;code&gt;String&lt;/code&gt;类型, 这里声明为&lt;code&gt;AnyObject&lt;/code&gt;, 然后就可以尝试访问&lt;code&gt;frame&lt;/code&gt;这个&lt;code&gt;String&lt;/code&gt;没有的property. 然后&lt;code&gt;frame&lt;/code&gt;会是&lt;code&gt;CGRect!&lt;/code&gt;类型并且值为&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果要链式访问, 安全的做法用&lt;strong&gt;?&lt;/strong&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; minX = value.frame?.minX  &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;CGFloat?&#39;&lt;/span&gt;

&lt;span class=&quot;hljs-comment&quot;&gt;// not safe&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; minX = value.frame.minX  &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;CGFloat!&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;method&quot;&gt;&lt;a href=&quot;#method&quot; class=&quot;headerlink&quot; title=&quot;method&quot;&gt;&lt;/a&gt;method&lt;/h2&gt;&lt;p&gt;方法和属性其实是一样的. 只不过可以被调用而已. 因此code也几乎一样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; result = value.stringByAppendingString?(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;)  &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;String?&#39;&lt;/span&gt;

&lt;span class=&quot;hljs-comment&quot;&gt;// not safe&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; result = value.stringByAppendingString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;)  &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;String&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;处理JSON&quot;&gt;&lt;a href=&quot;#处理JSON&quot; class=&quot;headerlink&quot; title=&quot;处理JSON&quot;&gt;&lt;/a&gt;处理JSON&lt;/h2&gt;&lt;p&gt;经常我们从HTTP请求拿到的是JSON, 转换成&lt;code&gt;NSDictionary&lt;/code&gt;或者&lt;code&gt;NSArray&lt;/code&gt;再传递给应用逻辑. 现在假设我们要获取JSON里面的信息.&lt;/p&gt;
&lt;h3 id=&quot;使用-valueForKey&quot;&gt;&lt;a href=&quot;#使用-valueForKey&quot; class=&quot;headerlink&quot; title=&quot;使用 valueForKey&quot;&gt;&lt;/a&gt;使用 valueForKey&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; name = value.valueForKey?(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是, 如果value不是Dict, 或者value是Array但是里面的元素不是Object, 这样就有可能引发 &lt;code&gt;valueForUndefinedKey:&lt;/code&gt;, 抛出exception. 当然, &lt;code&gt;valueForKeyPath&lt;/code&gt;也是一样的. &lt;/p&gt;
&lt;h3 id=&quot;使用-objectForKey&quot;&gt;&lt;a href=&quot;#使用-objectForKey&quot; class=&quot;headerlink&quot; title=&quot;使用 objectForKey&quot;&gt;&lt;/a&gt;使用 objectForKey&lt;/h3&gt;&lt;p&gt;所以呀, 既然认为value是JSON中的Object, 为什么不用更加自然的&lt;code&gt;objectForKey&lt;/code&gt;呢? &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; name = value.objectForKey?(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样当value不是dict, 也就没有objectForKey这个方法, 也就不会crash了. 然后name仍然是Optional. 
这样的假定在处理JSON时时有效的, 因为JSON支持的数据类型中只有object才有这个方法, 其他的array, boolean, number, string和null都没有.&lt;/p&gt;
&lt;h3 id=&quot;使用-下标语法&quot;&gt;&lt;a href=&quot;#使用-下标语法&quot; class=&quot;headerlink&quot; title=&quot;使用 下标语法&quot;&gt;&lt;/a&gt;使用 下标语法&lt;/h3&gt;&lt;p&gt;对于用key来访问还有个偏僻的小路可以走一下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; name = value[&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// will be `AnyObject?!`&lt;/span&gt;

&lt;span class=&quot;hljs-comment&quot;&gt;// or do this tricky way&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; name = value[&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;]?.flatMap{$&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;} &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;AnyObject?&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里用&lt;code&gt;flatMap&lt;/code&gt;只是一种对两层&lt;code&gt;Optional&lt;/code&gt;剥壳的手段, 用 &lt;code&gt;xx ?? nil&lt;/code&gt; 也能剥壳. 剥壳虽然比较丑, 但是却不会引起崩溃.&lt;/p&gt;
&lt;p&gt;如果要继续深入keyPath的话......&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; content = value[&lt;span class=&quot;hljs-string&quot;&gt;&quot;person&quot;&lt;/span&gt;]?.flatMap({$&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;})?[&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;]?.flatMap({$&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;}) &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;AnyObject?&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过我觉得最好还是用&lt;code&gt;objectForKey&lt;/code&gt;来从JSON获取信息, 并做好类型检查.&lt;/p&gt;
&lt;h2 id=&quot;总结-6&quot;&gt;&lt;a href=&quot;#总结-6&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;呵呵哒... 总结就是不要乱用, 少年, 除非你真的知道自己在做什么&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AnyObject&lt;/code&gt;在swift里面比较特别. 它是所有类都隐式实现的一个&lt;code&gt;protocol&lt;/code&gt;. Apple的注释里面写着当被用作一个具体类型时, 
所有&lt;code&gt;@objc&lt;/code&gt;的方法和属性都被编译器认为可以访问, 并且都被标记为隐式解包类型. &lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="swift" scheme="/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>集成NativeScript iOSRuntime到已有工程</title>
    <link href="/2016/04/11/nativescript/"/>
    <id>/2016/04/11/nativescript/</id>
    <published>2016-04-11T04:50:49.000Z</published>
    <updated>2016-04-12T12:22:44.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.nativescript.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NativeScript&lt;/a&gt;是一个保加利亚公司&lt;strong&gt;Telerik&lt;/strong&gt;开发的, 其目标比较受争议: &lt;code&gt;write once, run everywhere&lt;/code&gt;. 它提供了Android, Windows Phone和iOS的JS Runtime, 以及一些周边比如css和html的解析, 一些wrap的模块来消除不同平台的差异. 但是我们只需要它提供的Runtime来用JS开发原生应用就好, 因为写起来还不错.&lt;/p&gt;
&lt;h2 id=&quot;iOS-Runtime&quot;&gt;&lt;a href=&quot;#iOS-Runtime&quot; class=&quot;headerlink&quot; title=&quot;iOS Runtime&quot;&gt;&lt;/a&gt;iOS Runtime&lt;/h2&gt;&lt;p&gt;关于NativeScript的介绍可以去Google一下, 很多人拿来和&lt;a href=&quot;https://facebook.github.io/react-native/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-native&lt;/a&gt;比较, 一般对比比较多的是如何编写页面这一块. 当然这不是这篇文章的目的, 我只是比较在意NativeScript的Runtime, 它提供了js到原生的调用转换, 而且看起来挺不错. Android和Windows Phone没有研究过, 这里只聊聊iOS Runtime. 后文提到runtime如无特殊说明都是指iOS Runtime.
先看看code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; vc = UIView.alloc().init();
&lt;span class=&quot;hljs-comment&quot;&gt;// var vc = new UIViewController(); // same as last line&lt;/span&gt;

vc.view.backgroundColor = UIColor.redColor();

&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; nav = &lt;span class=&quot;hljs-comment&quot;&gt;/* some navigation controller */&lt;/span&gt;;

nav.pushViewControllerAnimated(vc, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);

&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来真的挺不错的. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;UIViewController&lt;/code&gt; 可以用 &lt;code&gt;new&lt;/code&gt;关键字, 也可以使用方法调用的形式.&lt;/li&gt;
&lt;li&gt;直接使用&lt;strong&gt;property&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;调用多个参数的API时, 是把所有的参数label都拼到了一起, 所以&lt;code&gt;pushViewController:Animated:&lt;/code&gt;转换成了&lt;code&gt;pushViewControllerAnimated&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;打日志还是&lt;code&gt;console.log&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多特性和限制看官网doc. 现在还支持了JS6, 看官方说明也支持TypeScript, 而且在和Angular team合作, 可以支持Angular2的样子.&lt;/p&gt;
&lt;p&gt;对了, 这货开源, Github上还提了一嘴:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The iOS runtime is written in a fun mix of C++, Objective-C, and more&lt;/strong&gt;. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后还有一个&lt;strong&gt;NativeScript Member&lt;/strong&gt; PanayotCankov 对issue的&lt;a href=&quot;https://github.com/NativeScript/NativeScript/issues/1121&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;回复&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the long term you may consider the ios-runtime is doing with JavaScript something similar to what Swift is doing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;呵呵...&lt;/p&gt;
&lt;h2 id=&quot;集成到现有工程&quot;&gt;&lt;a href=&quot;#集成到现有工程&quot; class=&quot;headerlink&quot; title=&quot;集成到现有工程&quot;&gt;&lt;/a&gt;集成到现有工程&lt;/h2&gt;&lt;p&gt;关于如何完全用&lt;strong&gt;NativeScript&lt;/strong&gt;写应用, 可以去官网看教程. 我这里就只记录一下集成Runtime到已有工程的步骤. &lt;strong&gt;NativeScript&lt;/strong&gt;在创建一个新应用时会生成iOS工程目录.
里面有一个叫做&amp;#39;internal&amp;#39;的文件夹. 所有的东西都在里面了.&lt;/p&gt;
&lt;h4 id=&quot;配置Build-Phases&quot;&gt;&lt;a href=&quot;#配置Build-Phases&quot; class=&quot;headerlink&quot; title=&quot;配置Build Phases&quot;&gt;&lt;/a&gt;配置Build Phases&lt;/h4&gt;&lt;p&gt;Runtime需要添加3个&lt;code&gt;run script&lt;/code&gt;. 可以照着样例工程里面来copy, 只要路径正确即可. 3个&lt;code&gt;run script&lt;/code&gt;分别是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;nativescript-pre-build&lt;/code&gt; 添加在&lt;strong&gt;Target Dependencies&lt;/strong&gt;后面.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nativescript-pre-link&lt;/code&gt; 添加在&lt;strong&gt;Compile Sources&lt;/strong&gt;后面.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nativescript-post-build&lt;/code&gt; 添加在最后, 这个是为了清除掉模拟器相关的切片, 不然Apple会拒.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;配置Build-Settings&quot;&gt;&lt;a href=&quot;#配置Build-Settings&quot; class=&quot;headerlink&quot; title=&quot;配置Build Settings&quot;&gt;&lt;/a&gt;配置Build Settings&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;internal&lt;/strong&gt;里面好几个xcconfig, 其实很简单的, 只用到了一个&lt;code&gt;nativescript-build.xconfig&lt;/code&gt;, 至于是用xcconfig还是直接裸写在setting里面, 看自己的需求. 
文件里面配置了&lt;code&gt;HEADER_SEARCH_PATHS&lt;/code&gt;, &lt;code&gt;OTHER_LDFLAGS&lt;/code&gt;以及&lt;code&gt;FRAMEWORK_SEARCH_PATHS&lt;/code&gt;. 这些值里面有些是相对路径, 自己调整正确就好. &lt;/p&gt;
&lt;p&gt;默认配置的是用&lt;code&gt;.a&lt;/code&gt;, 如果要改成用framework, 先在&lt;code&gt;OTHER_LDFLAGS&lt;/code&gt;里面去掉对&lt;code&gt;.a&lt;/code&gt;的引用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;-lNativeScript -L$(SRCROOT)/internal/NativeScript/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;lib&lt;/span&gt; //引用的是.&lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;, 删掉这个&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后把&lt;code&gt;NativeScript.framework&lt;/code&gt;拖拽到自己应用的Target的&lt;strong&gt;Embedded Binaries&lt;/strong&gt;里面, 这个framework是iOS8以后支持的dynamic framework. 
还需要在这个framework的根目录下添加一个&lt;strong&gt;Modules&lt;/strong&gt;文件夹, 在文件夹里面创建module.modulemap文件, 其内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;framework &lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt; NativeScript {
  umbrella header &lt;span class=&quot;hljs-string&quot;&gt;&quot;NativeScript.h&quot;&lt;/span&gt;

  &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; *
  &lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt; * { &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; * }
}&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;修改程序入口&quot;&gt;&lt;a href=&quot;#修改程序入口&quot; class=&quot;headerlink&quot; title=&quot;修改程序入口&quot;&gt;&lt;/a&gt;修改程序入口&lt;/h4&gt;&lt;p&gt;看了一下样例工程, 扒出来这几行关键&lt;strong&gt;OC&lt;/strong&gt;代码. swift怎么弄不会, 所以是OC哦.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#import &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;NativeScript/NativeScript.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// #import &quot;YourTarget-swift.h&quot; 如果用AppDelegate是swift类&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; startOfMetadataSection __&lt;span class=&quot;hljs-keyword&quot;&gt;asm&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;section$start$__DATA$__TNSMetadata&quot;&lt;/span&gt;);    &lt;span class=&quot;hljs-comment&quot;&gt;//抄过来的...&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; * argv[])
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;@autoreleasepool&lt;/span&gt; {
        [T&lt;span class=&quot;hljs-built_in&quot;&gt;NSRuntime&lt;/span&gt; initializeMetadata:&amp;amp;startOfMetadataSection];
        [T&lt;span class=&quot;hljs-built_in&quot;&gt;NSRuntimeInspector&lt;/span&gt; setLogsToSystemConsole:&lt;span class=&quot;hljs-literal&quot;&gt;YES&lt;/span&gt;];    &lt;span class=&quot;hljs-comment&quot;&gt;// 可以自己添加条件编译, 在release下扔掉&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;UIApplicationMain&lt;/span&gt;(argc, argv, &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([AppDelegate class]));
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果&lt;code&gt;APPDelegate&lt;/code&gt;是&lt;strong&gt;swift&lt;/strong&gt;写的, 需要添加&lt;strong&gt;Bridging Header&lt;/strong&gt;(避免build error), 并import一下swift到OC的转换头文件, 不是那个bridging header, 而是&lt;code&gt;YourTarget-swift.h&lt;/code&gt;那个文件. 详情查阅&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple文档&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h4&gt;&lt;p&gt;如果没啥问题的话, 应该就能build过了. 接下来简单配置一下, 创建一个目录比如&lt;code&gt;JS&lt;/code&gt;, 以文件夹引用的方式引入, 并将其设置为copy到mainBundle. 文件夹内添加一个&lt;code&gt;app.js&lt;/code&gt;文件, 随便写点儿log神马的.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; runtime = &lt;span class=&quot;hljs-type&quot;&gt;TNSRuntime&lt;/span&gt;(applicationPath: appPath)    &lt;span class=&quot;hljs-comment&quot;&gt;// 指向文件夹&lt;/span&gt;
runtime.scheduleInRunLoop(&lt;span class=&quot;hljs-type&quot;&gt;NSRunLoop&lt;/span&gt;.mainRunLoop(), forMode: &lt;span class=&quot;hljs-type&quot;&gt;NSRunLoopCommonModes&lt;/span&gt;)

runtime.executeModule(&lt;span class=&quot;hljs-string&quot;&gt;&quot;./&quot;&lt;/span&gt;)     &lt;span class=&quot;hljs-comment&quot;&gt;// 执行app.js&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;&gt;&lt;/a&gt;存在的问题&lt;/h2&gt;&lt;p&gt;目前也只是刚扒出来, 网上的资料比较少, 对&lt;strong&gt;JavaScriptCore&lt;/strong&gt;也不是很了解, 弄起来比较费劲. 目前存在一些问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;TNSRuntime&lt;/code&gt;对象有个&lt;code&gt;globalContext&lt;/code&gt;方法返回&lt;code&gt;JSGlobalContextRef&lt;/code&gt;, 但是拿去创建&lt;code&gt;JSContext&lt;/code&gt;就会崩溃, 报&lt;strong&gt;WTFCrash&lt;/strong&gt;... 不过直接用C的API去执行JS貌似没事. 只要想要retain, 或者copyName都会导致crash. 不知道原因.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每次build都要消耗一定时间去generate metadata. SSD大概十几秒的样子?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供了一大堆module, 用得上的没几个. 代码是直接复制到app bundle, 等于开源了, 当然处理一下也是可以的.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;p&gt;其实研究一下它主要是看中它JS编写原生页面的能力, coding起来跟写OC或者swift很像, 而且可以完全不理会它提供的包, 依然用自己熟悉的方式开发. 学习成本几乎为0啊. 感觉如果认真研究一下, 配置成远端下载脚本到本地执行应该是没有问题(可能有不少坑). 这样热更新应用, 甚至去掉h5, 改用NativeScript来提供页面都可以尝试, 原生效果肯定比h5好啊.&lt;/p&gt;
&lt;p&gt;还有它遵循&lt;strong&gt;CommonJS&lt;/strong&gt;, 可以打包一些js的库来用, 挺方便的. &lt;/p&gt;
&lt;p&gt;最重要的一点最后说: 它是在编译的时候调用generate metadata去生成API的映射, 在执行js之前会load几个常用模块比如UIKit, Foundation, 然后有些模块会在第一次调用的时候load. 如果iOS更新了, 你不需要更新NativeScript, 即可立即开始使用新API, 因为你编译的时候新的API就会被检索, 被放到metadata里面. &lt;/p&gt;
&lt;p&gt;其他的比如&lt;strong&gt;Xamarin&lt;/strong&gt;就必须等SDK更新才能有机会调用新的API, 而&lt;strong&gt;React-Native&lt;/strong&gt; 目前只能通过写模块来和native通信, 不具备直接调用的能力.&lt;/p&gt;
&lt;p&gt;如果再有其他进展, 再继续更新本文.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nativescript.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NativeScript&lt;/a&gt;是一个保加利亚公司&lt;strong&gt;Telerik&lt;/strong&gt;开发的, 其目标比较受争议: &lt;c
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="NativeScript" scheme="/tags/NativeScript/"/>
    
  </entry>
  
  <entry>
    <title>swift 2.2 类型转换小坑</title>
    <link href="/2016/03/28/swift_type_convert/"/>
    <id>/2016/03/28/swift_type_convert/</id>
    <published>2016-03-28T06:00:00.000Z</published>
    <updated>2016-04-17T03:36:09.000Z</updated>
    
    <content type="html">&lt;p&gt;XCode升级到了7.3, swift到了2.2. 之前发现的坑在这里验证了一下, 依然没啥变化. 特此记录一下.&lt;/p&gt;
&lt;p&gt;本文主要填一下类型转换的坑, 包括 &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;Optional&lt;/code&gt;, &lt;code&gt;函数参数&lt;/code&gt;,&lt;code&gt;闭包&lt;/code&gt; 以及&lt;code&gt;Tuple&lt;/code&gt;. 总之, &lt;code&gt;class&lt;/code&gt;和&lt;code&gt;非class&lt;/code&gt;的待遇是不一样的, Any和AnyObject的区别也是很重要的.
&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;主要是针对Array类型, 其他&lt;code&gt;CollectionType&lt;/code&gt;也类似.&lt;/p&gt;
&lt;p&gt;本文代码中的通用定义:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt; &lt;/span&gt;{}    &lt;span class=&quot;hljs-comment&quot;&gt;//swift protocol without @objc&lt;/span&gt;

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;{}
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;B&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;{}

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AP&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt; &lt;/span&gt;{}
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BP&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;AP&lt;/span&gt; &lt;/span&gt;{}

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;S&lt;/span&gt; &lt;/span&gt;{}
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SP&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt; &lt;/span&gt;{}

&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; arrayA = [&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()], arrayB = [&lt;span class=&quot;hljs-type&quot;&gt;B&lt;/span&gt;()], arrayS = [&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;()], arrayPA: [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;] = [&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()], arrayPS: [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;] = [&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;()]&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;as-is-以及-Optional&quot;&gt;&lt;a href=&quot;#as-is-以及-Optional&quot; class=&quot;headerlink&quot; title=&quot;as is, = 以及 Optional&quot;&gt;&lt;/a&gt;as is, = 以及 Optional&lt;/h2&gt;&lt;p&gt;三者的坑类似, 主要是array类型的推断. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;as&lt;/code&gt;操作符将一个类型转换成平级类型或者父类型, 例如 &lt;code&gt;&amp;quot;abc&amp;quot; as NSString&lt;/code&gt;可以看成是平级转换, &lt;code&gt;b as A&lt;/code&gt; 是转换到父类型.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as!&lt;/code&gt;和&lt;code&gt;as?&lt;/code&gt;是用于将父类型变量转换为子类型.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is&lt;/code&gt;是check父类型变量是否为子类型.&lt;/li&gt;
&lt;li&gt;某种程度上, &lt;code&gt;Optional&lt;/code&gt;可以看做是其&lt;code&gt;T&lt;/code&gt;的父类型.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;普通类型进行各种转换检查都没什么问题, 但是当普通类型碰上&lt;strong&gt;集合&lt;/strong&gt;呢? &lt;/p&gt;
&lt;p&gt;先看code:&lt;/p&gt;
&lt;p&gt;as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;arrayA &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;]  &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
arrayA &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;]    &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
arrayA &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;AnyObject&lt;/span&gt;]    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;
arrayB &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;]            &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;

arrayS &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;]    &lt;span class=&quot;hljs-comment&quot;&gt;// compiler, Cannot convert value of type &#39;[C]&#39; to type &#39;[P]&#39; in coercion&lt;/span&gt;
arrayS &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;]    &lt;span class=&quot;hljs-comment&quot;&gt;// compiler, Cannot convert value of type &#39;[C]&#39; to type &#39;[Any]&#39; in coercion&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;arrayPA &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;
arrayPS &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: can&#39;t unsafeBitCast between types of different sizes&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;赋值:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a: [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;] = arrayA &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a: [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;] = arrayA &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a: [&lt;span class=&quot;hljs-type&quot;&gt;AnyObject&lt;/span&gt;] = arrayA &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; s: [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;] = arrayS &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; s: [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;] = arrayS &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大概是因为OC的runtime吧. 可不是么? 文档有提到&lt;code&gt;@objc&lt;/code&gt; 将指定的方法或者属性暴露给OC, 而&lt;code&gt;AnyObject&lt;/code&gt;是带有这个标记的, 因此在类型检查和转换时行为跟&lt;code&gt;NSArray&lt;/code&gt;差不多. &lt;code&gt;Any&lt;/code&gt;没有&lt;code&gt;@objc&lt;/code&gt;. &lt;code&gt;protocol&lt;/code&gt; 不带&lt;code&gt;@objc&lt;/code&gt;时和&lt;code&gt;Any&lt;/code&gt;一样, 带上了&lt;code&gt;@objc&lt;/code&gt;就和&lt;code&gt;AnyObject&lt;/code&gt;一样. &lt;code&gt;Optional&lt;/code&gt;也是swift特有, 因此行为上和Any类似.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;arrayA &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;NSArray&lt;/span&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;
arrayS &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;NSArray&lt;/span&gt;     &lt;span class=&quot;hljs-comment&quot;&gt;// // compiler, Cannot convert value of type &#39;[S]&#39; to type &#39;NSArray&#39; in coercion&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只要不牵扯到swift特有的东西(struct, 不带@objc的protocol, Optional), 大部分的转换都可以看成是到NSArray的转换, 当然swift也有类型检查, 不能乱转. &lt;/p&gt;
&lt;p&gt;然而事情总有意外...&lt;/p&gt;
&lt;p&gt;真的只能这样了么? 不是的. 字面量数组可以躲过一些劫难. 因为类型推断的缘故. 继续看code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;[&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;]
[&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;]
[&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;AnyObject&lt;/span&gt;]

[&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;]
[&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类型推断至上而下, 表达式的类型最终为[P], 倒推左值需要为[P], 此时左值只知道是Array, 未推断T, 进而继续推断其Generator.Element需要为P. 而A可以转换为P, 所以字面量数组创建出来就是[P]类型而不存在转换. 这是编译器做的.&lt;/p&gt;
&lt;p&gt;赋值的操作类似, 只要把右值换成对应的字面量数组就可以成功赋值, 而&lt;code&gt;is&lt;/code&gt;操作因为类型推断, 字面量数组最终的类型就是右值, 没有意义. &lt;/p&gt;
&lt;p&gt;哦, 类型推断哪...&lt;/p&gt;
&lt;h2 id=&quot;函数参数-和-闭包&quot;&gt;&lt;a href=&quot;#函数参数-和-闭包&quot; class=&quot;headerlink&quot; title=&quot;函数参数 和 闭包&quot;&gt;&lt;/a&gt;函数参数 和 闭包&lt;/h2&gt;&lt;p&gt;函数有入参和返回值, 调用函数时传递参数也是一个赋值的过程, 因此可以参考上文的现象. 也就是说传递进来的参数要能正确转换成函数需要的类型, 函数内部的返回值也要能正确转换为声明的类型. 只要符合这些条件, 调用就没有问题.&lt;/p&gt;
&lt;p&gt;那么问题来了, 闭包也是函数, 闭包的类型如何转换?&lt;/p&gt;
&lt;p&gt;又来一份code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f: A -&amp;gt; P)&lt;/span&gt;&lt;/span&gt; {}
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(p: P)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt; {}

test(param)    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原理并不难, 先看闭包的入参, 需求为A类型, 也就意味着在&lt;code&gt;test&lt;/code&gt;方法内部会传递一个变量给&lt;code&gt;f&lt;/code&gt;, 这个变量会在传递给&lt;code&gt;f&lt;/code&gt;时转换为&lt;code&gt;A&lt;/code&gt;类型. 也就是说&lt;code&gt;f&lt;/code&gt;应该能够处理&lt;code&gt;A&lt;/code&gt;类型的入参.因此, 如果我们传递的闭包的入参是&lt;code&gt;A&lt;/code&gt;的父类型&lt;code&gt;P&lt;/code&gt;, 它也能处理类型为&lt;code&gt;A&lt;/code&gt;的参数, 而如果是子类型&lt;code&gt;B&lt;/code&gt;则可能出错. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;一定是&lt;code&gt;P&lt;/code&gt;但不一定是&lt;code&gt;B&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;同样, 对于返回值, &lt;code&gt;test&lt;/code&gt;方法要返回&lt;code&gt;P&lt;/code&gt;类型, 因此我们可以返回&lt;code&gt;P&lt;/code&gt;类型的子类型&lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;前文提到, 某种程度上可以将&lt;code&gt;Optional&lt;/code&gt;看做是其&lt;code&gt;T&lt;/code&gt;的父类型, 因为编码过程中发现它在类型转换上的结果和父类型子类型的一致.因此下面的code也不需要特别处理:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testNil&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;? {
    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a         &lt;span class=&quot;hljs-comment&quot;&gt;// 编译器自动wrap&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Tuple&quot;&gt;&lt;a href=&quot;#Tuple&quot; class=&quot;headerlink&quot; title=&quot;Tuple&quot;&gt;&lt;/a&gt;Tuple&lt;/h2&gt;&lt;p&gt;Tuple没有什么特别的, 就是类型转换的时候不管类型继承, 当然, 字面量方式除外. 看起来就像是字符串比较:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; value = (&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;(), &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;)    &lt;span class=&quot;hljs-comment&quot;&gt;// value 是 (P, P)类型&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; value &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;) {

} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-comment&quot;&gt;// will got here&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;总结-5&quot;&gt;&lt;a href=&quot;#总结-5&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;写的时候尽量注意吧, 不要以为build过了就没事, 一些转换的坑在runtime等你呢(看上边的报错的注释吧). 拿不准就主动做个map吧.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;XCode升级到了7.3, swift到了2.2. 之前发现的坑在这里验证了一下, 依然没啥变化. 特此记录一下.&lt;/p&gt;
&lt;p&gt;本文主要填一下类型转换的坑, 包括 &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;, &lt;cod
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="swift" scheme="/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>2016 年后小总结</title>
    <link href="/2016/03/15/%E5%B9%B4%E5%90%8E%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>/2016/03/15/年后小总结/</id>
    <published>2016-03-15T07:00:00.000Z</published>
    <updated>2016-04-05T13:05:40.000Z</updated>
    
    <content type="html">&lt;p&gt;kaizei的2015小总结. 总算也是写了总结了...&lt;/p&gt;
&lt;p&gt;问: 不应该年前写总结么?&lt;/p&gt;
&lt;p&gt;答: 是的, 但是... hehe
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每个人都有自己可以填在但是后面的话, 我的是什么? 不告诉你.&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;过完年了, 嗯, 不用提醒我已经过了1个多月了. 去年一年很颠簸, 跳了两次槽, 2月份离开人人去了tango, 然后8月份离开tango来到了现在的公司--财说. &lt;/p&gt;
&lt;p&gt;技术上还是那样, iOS为主, 公司使用swift开发, 经历了1到2的迁移, 我们的代码质量蛮高, 结构也比较合理, 很少的时间就完成了. 年底用swift开发了几个库, &lt;a href=&quot;https://github.com/kaizeiyimi/XLYAnimatedImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;动图播放&lt;/a&gt;, &lt;a href=&quot;https://github.com/kaizeiyimi/XAutoLayout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XAutoLayout&lt;/a&gt;,  &lt;a href=&quot;https://github.com/kaizeiyimi/XLYTextKitExtension&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;扩展TextKit&lt;/a&gt;, &lt;a href=&quot;https://github.com/kaizeiyimi/Phantom&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Phantom&lt;/a&gt;, 前两个的质量高一些, 后面两个更像是试验品. 吐槽一句: 用swift开发和只是站在旁边学习是完全不一样的. 😛&lt;/p&gt;
&lt;p&gt; 有空倒腾了一下web技术, 感觉web技术才是未来的霸主. 断断续续看了一些js的书籍, 也倒腾了一些工具, &lt;code&gt;gulp&lt;/code&gt;, &lt;code&gt;browser-sync&lt;/code&gt;之类的, 还挺有意思的.&lt;/p&gt;
&lt;p&gt;生活上有点儿悲催. 工作性质加上我一般比较投入, 久坐较多, 人胖了, 气色差了, 头发少了, 脾气也没以前好了, 总之整个人都不好了. 搬家也搬了两次, 租房住的悲哀. 现在又回到了最开始的地荒--立水桥. 立水桥还是那个立水桥, 但是房租已经不是那个价位的房租了. 卖方市场下的我们也只能挣扎却无法摆脱年年涨租的问题.&lt;/p&gt;
&lt;p&gt;今年要多多锻炼身体, 多看点儿文学书籍. 篮球已经瘪了, 要打气了. 吉他上的灰很多, 要擦一下了. &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color:rgb(179,62,170)&quot;&gt;darling&lt;/span&gt;说, 身上的肉肥了, 再不锻炼就该割了!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;kaizei的2015小总结. 总算也是写了总结了...&lt;/p&gt;
&lt;p&gt;问: 不应该年前写总结么?&lt;/p&gt;
&lt;p&gt;答: 是的, 但是... hehe
    
    </summary>
    
      <category term="日常" scheme="/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="年终总结" scheme="/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>XLYAutoLayoutEasy</title>
    <link href="/2014/12/08/XLYAutoLayoutEasy/"/>
    <id>/2014/12/08/XLYAutoLayoutEasy/</id>
    <published>2014-12-08T08:00:00.000Z</published>
    <updated>2016-04-04T10:07:09.000Z</updated>
    
    <content type="html">&lt;p&gt;开发AutoLayoutEasy的目的是为了让代码编写AutoLayout更加方便直观, 提高可读性和可维护性. 因为我个人觉得iOS提供的创建约束的方式真心不敢恭维, NSLayoutConstraint的类方法写起来好长, VFL又不好操作具体约束, 写出来的代码可读性也不是很高.&lt;/p&gt;
&lt;h2 id=&quot;如何创建一个约束&quot;&gt;&lt;a href=&quot;#如何创建一个约束&quot; class=&quot;headerlink&quot; title=&quot;如何创建一个约束&quot;&gt;&lt;/a&gt;如何创建一个约束&lt;/h2&gt;&lt;p&gt;苹果在NSLayoutConstraint中提供了一个类方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;+(instancetype)constraintWithItem:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)view1 
                        attribute:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutAttribute&lt;/span&gt;)attr1 
                        relatedBy:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutRelation&lt;/span&gt;)relation
                           toItem:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)view2 
                        attribute:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutAttribute&lt;/span&gt;)attr2 
                       multiplier:(&lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat&lt;/span&gt;)multiplier 
                         constant:(&lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat&lt;/span&gt;)c;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用于创建两个item之间的约束, 一次只能描述某两个属性的关系. 比如需要view1的left和view2的right保持10的偏移量. 那么这里的调用就是这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutConstraint&lt;/span&gt; constraintWithItem:view1 
                             attribute:&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutAttributeLeft&lt;/span&gt;
                             relatedBy:&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutRelationEqual&lt;/span&gt;
                                toItem:view2
                             attribute:&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutAttributeRight&lt;/span&gt;
                            multiplier:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
                              constant:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好长有木有, 但是很清晰, 至少明确地表达了两个view的两个属性间的关系. VFL的描写方式就不写了. 这里获取到了一个constraint对象, 下一步我需要让它生效, 我需要找到一个view去调用&lt;code&gt;[view addConstraint:constraint]&lt;/code&gt;, 这个view必须是view1和view2的一个公共父view. 完成操作后, 等到下一个刷新周期约束就会生效了.&lt;/p&gt;
&lt;h2 id=&quot;XLYAutoLayoutEasy&quot;&gt;&lt;a href=&quot;#XLYAutoLayoutEasy&quot; class=&quot;headerlink&quot; title=&quot;XLYAutoLayoutEasy&quot;&gt;&lt;/a&gt;XLYAutoLayoutEasy&lt;/h2&gt;&lt;p&gt;虽然创建约束的方法很直观, 但是我仍然认为它太复杂, 太长了. 屏幕杀手. 先看一眼我的lib如何描写一个约束.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;  view1.layoutLeft.equalTo(view2.layoutRight).constant(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;怎么看都更加简单. &lt;strong&gt;简化约束的创建是XLYAutoLayoutEasy的核心&lt;/strong&gt;, 所有的约束创建都使用类似的方法. 如果firstItem和secondItem使用相同的layout属性, 可以不用书写secondItem的layout属性. 如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;//view1的宽度等于view2的宽度乘1再加上10&lt;/span&gt;
  view1.layoutWidth.equalTo(view2).constant(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是根superView的对应属性做约束, 甚至可以写成这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;//等同view1.layoutLeading.equalTo(superView.layoutLeading).constant(100);&lt;/span&gt;
  view1.layoutLeading.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的单行代码创建的是XLYConstraint对象, 需要调用resultConstraint来获取NSLayoutConstraint对象.&lt;/p&gt;
&lt;p&gt;XLYAutoLayoutEasy还顺带提供了一些helper方法, 辅助激活, 更新和重建约束. &lt;/p&gt;
&lt;h4 id=&quot;批量创建约束&quot;&gt;&lt;a href=&quot;#批量创建约束&quot; class=&quot;headerlink&quot; title=&quot;批量创建约束&quot;&gt;&lt;/a&gt;批量创建约束&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; makeConstraints:^{
  testView.layoutTop.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.topLayoutGuideView.layoutBottom).constant(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;);
  testView.layoutTrailing.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view).constant(&lt;span class=&quot;hljs-number&quot;&gt;-50&lt;/span&gt;);
  testView.layoutLeading.equalToConstant(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;);
  testView.layoutHeight.equalToConstant(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
}];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用makeConstraint的方法会自动将block里面创建的约束激活, 无需再自行寻找公共父view进行添加.&lt;/p&gt;
&lt;h4 id=&quot;更新约束&quot;&gt;&lt;a href=&quot;#更新约束&quot; class=&quot;headerlink&quot; title=&quot;更新约束&quot;&gt;&lt;/a&gt;更新约束&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; updateConstraints:^{
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutLeading.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view).constant(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutHeight.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;);
}];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有在updateConstraints里面创建的约束会首先查找有没有一个约束和创建出来的约束相似(后文会解释相似的判定), 如果有, 则修改constant, 否则添加新创建的约束. 
如果使用iOS的方法, 则需要记录下之前创建的约束来修改constant. &lt;/p&gt;
&lt;h4 id=&quot;重建约束&quot;&gt;&lt;a href=&quot;#重建约束&quot; class=&quot;headerlink&quot; title=&quot;重建约束&quot;&gt;&lt;/a&gt;重建约束&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; remakeConstraints:^{  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutBottom.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.bottomLayoutGuideView.layoutTop).constant(&lt;span class=&quot;hljs-number&quot;&gt;-100&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutWidth.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutHeight.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutLeading.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view.layoutLeading);
}];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法会记录所有在remakeConstraints中出现的作为firstItem的view, 并把跟这些view相关的所有约束去掉(不包含hugging, compression resistance 的约束), 然后重新激活新创建的约束.&lt;/p&gt;
&lt;h2 id=&quot;灵感&quot;&gt;&lt;a href=&quot;#灵感&quot; class=&quot;headerlink&quot; title=&quot;灵感&quot;&gt;&lt;/a&gt;灵感&lt;/h2&gt;&lt;p&gt;大前提是&lt;code&gt;translatesAutoresizingMaskIntoConstraints = NO&lt;/code&gt;. 否则无法玩耍了. 既然使用了autoLayout就不要再搭着AutoResizingMask了.&lt;/p&gt;
&lt;p&gt;简单描述一下XLYAutoLayoutEasy的设计灵感来源. 在storyboard中编辑一个约束时, 我发现xcode标注了firstItem, relation, secondItem, constant, priority, multiplier. 其中firstItem和secondItem显示的是view.width这样的形式, 整个约束看起来十分清晰. 于是想到如果能在代码里面用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;view1&lt;span class=&quot;hljs-selector-class&quot;&gt;.width&lt;/span&gt; equalTo view2&lt;span class=&quot;hljs-selector-class&quot;&gt;.width&lt;/span&gt;, constant &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;, priority &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;, multiplier &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的形式描述那多好.一下就看明白了. 于是想到给UIView添加分类, 提供类似width, height, leading这样的property. 为了准确表达是布局的属性, 在前面添加了layout, 于是就成了layoutWidth, layoutHeight, layoutLeading. 没有添加xly_的前缀是为了书写方便.
 首先定义了最基础的API:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;view.layoutWidth.equalTo(view2.layoutWidth);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关系有等于, 大于等于, 小于等于. constant, priority以及multiplier都有默认值, 分别是0, 1000, 1. 如果需要修改的话, 就在上面的表达式后面继续书写:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;view.layoutWidth.equalTo(view2.layoutWidth).constant(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;).priority(&lt;span class=&quot;hljs-number&quot;&gt;750&lt;/span&gt;).multiplier(&lt;span class=&quot;hljs-number&quot;&gt;1.5&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这三个属性书写的顺序可以随意交换.但是一定是在关系之后.&lt;/p&gt;
&lt;p&gt;这样的形式更像c或者swift的语法, OC里面怎么做呢? 用block. block在调用时是block()的形式. 只要返回值可以使用&lt;code&gt;.&lt;/code&gt; 进行调用的话这样的书写就没有问题. 因此就诞生了如下的方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;    - (XLYConstraint *(^)(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; attr))equalTo;
    - (XLYConstraint *(^)(&lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat&lt;/span&gt; constant))constant;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用block作为返回值, 然后用()进行调用, 得到XLYConstraint的对象, 然后重复. 这样就能写出上面所展示的那种代码了. 我觉得这里如果用&lt;code&gt;[]&lt;/code&gt; 进行方法调用的话, 可读性会比较差, 所以...&lt;/p&gt;
&lt;p&gt;&lt;code&gt;view.layoutXXX&lt;/code&gt;这样的属性是XLYViewAttribute类型, 调用equalTo等描述关系的方法后才产生XLYConstraint对象, 这样做一方面是为了从概念上区分出约束的item和其他参数, 另一方面也方便了代码的分布.&lt;/p&gt;
&lt;p&gt;通过这样的调用最终生成的XLYConstraint对象记录了一个约束所需要的8个参数. 然后调用其&lt;code&gt;resultConstraint&lt;/code&gt;方法将生成所对应的NSLayoutConstraint对象.&lt;/p&gt;
&lt;h2 id=&quot;helper方法&quot;&gt;&lt;a href=&quot;#helper方法&quot; class=&quot;headerlink&quot; title=&quot;helper方法&quot;&gt;&lt;/a&gt;helper方法&lt;/h2&gt;&lt;p&gt;一个约束被创建后需要激活. ios7及以下系统需要自己寻找公共父view并添加, 因此我需要一个寻找两个view公共父view的方法. ios8及以上系统只需要设置active为YES即可.
在更新约束时, 我需要寻找到和当前约束&amp;#39;类似&amp;#39;的约束. 
在重建约束时, 我需要找到跟一个view相关联的所有约束.&lt;/p&gt;
&lt;p&gt;以上就是make, update和remake所依赖的核心方法.&lt;/p&gt;
&lt;h4 id=&quot;激活约束&quot;&gt;&lt;a href=&quot;#激活约束&quot; class=&quot;headerlink&quot; title=&quot;激活约束&quot;&gt;&lt;/a&gt;激活约束&lt;/h4&gt;&lt;p&gt;给NSLayoutConstraint添加了一个分类, 提供了xly_install 和 xly_uninstall方法来进行激活和移除操作, 方法中根据系统版本进行区别调用. 如果是ios8及以上只需设置active属性, ios7及以下则需要寻找最低公共父view来进行添加.&lt;/p&gt;
&lt;h4 id=&quot;更新约束-1&quot;&gt;&lt;a href=&quot;#更新约束-1&quot; class=&quot;headerlink&quot; title=&quot;更新约束&quot;&gt;&lt;/a&gt;更新约束&lt;/h4&gt;&lt;p&gt;更新约束时, 首先是创建了在block里面书写的约束, 然后去寻找是否有一个相似的约束, 如果没有的话就直接激活约束, 如果有就替换constant的值.&lt;/p&gt;
&lt;p&gt;什么是相似? 从NSLayoutConstraint中能看出来, 创建完一个约束后能修改的值只有priority和constant, priority还不建议在约束激活后再修改. 虽然经过测试发现只要优先级不是1000, 并且改动后的值也不是1000就没有问题, 否则崩溃. 这里尊重苹果的文档, 把优先级不同的约束当成不同的约束. 因此,相似的概念就是除了constant以外, 其他的值是&lt;strong&gt;逻辑相等&lt;/strong&gt;的. 为什么不是完全相等? 因为约束并不是单向的, 它是一个双向的限制, 约束的公式如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;view1.attr1 = view2.attr2 * multiplier + &lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个计算规则等同于下面这一个:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;view2.attr2 = view1.attr1 * ( &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/multiplier) - &lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;/multiplier&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此, 在寻找相似的约束时必须考虑第二种形式. 我定义相似的结果为3种, 相似, 逆向相似以及不相似. 查找时还得小心一种很特别的约束, 是通过设置view的hugging和compression resistance生成的. 这种约束的类是&lt;code&gt;NSContentSizeLayoutConstraint&lt;/code&gt;, 需要过滤掉. 最后一个细节就是相似的约束可能不止一个, 这种情况下多半是代码有问题, 约束加多了, 但是不管怎么着, 我只取最新的一个, 即最后添加的那个, 因此我会倒序遍历constraints数组来进行查找.&lt;/p&gt;
&lt;h4 id=&quot;重建约束-1&quot;&gt;&lt;a href=&quot;#重建约束-1&quot; class=&quot;headerlink&quot; title=&quot;重建约束&quot;&gt;&lt;/a&gt;重建约束&lt;/h4&gt;&lt;p&gt;重建, 就得先毁灭再重生. 应该被毁灭的是哪些呢? 我善做主张, 将所有关联的约束全部干掉. 比如代码这么写:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; remakeConstraints:^{  
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutBottom.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.bottomLayoutGuideView.layoutTop).constant(&lt;span class=&quot;hljs-number&quot;&gt;-100&lt;/span&gt;);
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutWidth.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutHeight.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutLeading.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view.layoutLeading);
  &lt;span class=&quot;hljs-comment&quot;&gt;//这里不再多写了, view2也进行重建&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view2 ...
}];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;block里创建了多个约束, 作为firstItem出现的是testView和view2, 因此所有和testView和view2有关联的约束全部干掉. 约束是双向的, 有关联就是约束的firstItem或者secondItem等于这个view. 在寻找关联的约束时只能从自己开始, 逐步往window遍历所有的约束, 将关联的约束记下. 这里本来想利用runtime去替换addConstant和setActive方法, 在方法中进行记录的, 但是发现了iOS的一些诡异得无法解释的现象, 放弃了这条路, 只能每次遍历查找了, 效率相对低点儿. 这里同样要去掉&lt;code&gt;NSContentSizeLayoutConstraint&lt;/code&gt;类型的约束.&lt;/p&gt;
&lt;h2 id=&quot;兼顾swift&quot;&gt;&lt;a href=&quot;#兼顾swift&quot; class=&quot;headerlink&quot; title=&quot;兼顾swift&quot;&gt;&lt;/a&gt;兼顾swift&lt;/h2&gt;&lt;p&gt;以上的代码如果bridge到swift使用将显得很funny. 因为方法返回的是一个闭包, OC直接使用()就可以跟在后面继续调用, 但是swift会变成这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;  view1.layoutLeft.equalTo()(view2.layoutRight).constant()(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此, 我专门为swift添加了两个头文件, 使得swift里面也能跟OC的写法一样.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//其中一个, 另一个见代码&lt;/span&gt;
- (XLYConstraint *)equalTo:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)attr;
- (XLYConstraint *)greaterThanOrEqualTo:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)attr;
- (XLYConstraint *)lessThanOrEqualTo:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)attr;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也专门弄了一个给swift bridge header用的&lt;code&gt;XLYAutoLayoutEasy-swift.h&lt;/code&gt;以区分import的头文件.&lt;/p&gt;
&lt;h2 id=&quot;总结-3&quot;&gt;&lt;a href=&quot;#总结-3&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;用helper方法配合简化约束的写法, 就能用较短的代码量写出我认为更加清晰可读的布局代码. 更新重建的操作也能更加容易. &lt;/p&gt;
&lt;p&gt;写代码, 多思考, 想清楚了需要什么再写. 多画图有助于思考.&lt;/p&gt;
&lt;p&gt;另外, 感谢我的她对我的包容和支持.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;开发AutoLayoutEasy的目的是为了让代码编写AutoLayout更加方便直观, 提高可读性和可维护性. 因为我个人觉得iOS提供的创建约束的方式真心不敢恭维, NSLayoutConstraint的类方法写起来好长, VFL又不好操作具体约束, 写出来的代码可读性
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="GitHub" scheme="/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>AutoLayout的小吐槽</title>
    <link href="/2014/12/08/talk_about_autolayout/"/>
    <id>/2014/12/08/talk_about_autolayout/</id>
    <published>2014-12-08T03:00:00.000Z</published>
    <updated>2016-04-04T10:07:40.000Z</updated>
    
    <content type="html">&lt;p&gt;突然有一天, 苹果还在ios6的时候, 它发布了新的布局方式, 取名叫&lt;strong&gt;AutoLayout&lt;/strong&gt;, 听着很高大上--自动布局. 但是我这篇文章除了简单介绍一下它以外更多的是要吐槽的, 其实也就稍微吐一点点它的使用问题.&lt;/p&gt;
&lt;h2 id=&quot;AutoResizing-AutoLayout之前的布局&quot;&gt;&lt;a href=&quot;#AutoResizing-AutoLayout之前的布局&quot; class=&quot;headerlink&quot; title=&quot;AutoResizing -- AutoLayout之前的布局&quot;&gt;&lt;/a&gt;AutoResizing -- AutoLayout之前的布局&lt;/h2&gt;&lt;p&gt;做app必然涉及到布局, 现在改为自动布局的话, 那么以前的布局是什么, AutoLayout解决了什么问题?&lt;/p&gt;
&lt;p&gt; 以前的布局方式我觉得可以叫做半自动布局. 因为AutoResizing是一种spring-strut方式, 仅描述了view在其superView大小变化时自身如何变化. 它可以描述一个view相对于superView的上下左右四个边距是否固定, 自身的宽高是否可以拉伸这么6个属性, 对于大部分的app来讲AutoResizing已经足够描述布局规则了. &lt;/p&gt;
&lt;p&gt; 但是如果view的大小不好计算(依赖内容)或者有多个view有相互依赖的关系, AutoResizing就不够用了, 并且布局将变得很繁琐无聊容易出错.&lt;/p&gt;
&lt;p&gt; 布局的方式大致如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可能需要对view调用sizeToFit 或者其他方法来将view的frame调整到一个合适的大小.&lt;/li&gt;
&lt;li&gt;也可以在某个父view的layoutSubviews方法中根据需求调整这些view的大小并计算这些view的各种位置. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中最麻烦的就是字体相关的布局计算, 因为文字渲染后的行高都略大于字号, 没法直接设定label高度, 必须用NSString的一个分类方法计算在一定条件下的渲染大小, 然后才能参与计算.&lt;/p&gt;
&lt;h2 id=&quot;AutoLayout-解决的问题&quot;&gt;&lt;a href=&quot;#AutoLayout-解决的问题&quot; class=&quot;headerlink&quot; title=&quot;AutoLayout 解决的问题&quot;&gt;&lt;/a&gt;AutoLayout 解决的问题&lt;/h2&gt;&lt;p&gt;AutoLayout试图解决控件大小变化以及位置变化的问题. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;控件大小的问题: 比如label控件默认情况下会有比较低的优先级阻止自身变大, 相对较高的优先级阻止自身被压缩, 在不引起变大或者压缩的情况下, label会保持和内容一样大. 你仍然可以固定它的大小, 但是不建议. 当你改变了text, label自动就会调整大小, 不需要你再去为了label的宽高抓狂了. 当然, 有的场景仍然需要手动计算文字渲染后大小.  另外一种大小问题是相对计算的, 比如一个view的大小或者位置会影响到另一个view的大小, 当这个view变化时另一个的大小也会相应变化.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;控件位置问题: AutoLayout最直接的表现就是能够定义两个控件之间的相对位置. 比如view1相对view2保持10的间距, 那么当view1的origin改变时, view2的origin也会随之变化.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然用AutoLayout进行布局看起来是很好的, 事实上也是很好的, 尽管不是那么完美. storyboard和AutoLayout可以帮助开发者将绝大部分的UI逻辑和业务逻辑分离开, 并且修改和维护的复杂性也还能接受, 习惯了的话也是能很较快速地调整约束的.&lt;/p&gt;
&lt;p&gt;AutoLayout中一次只能描述一个view的宽高或者描述两个view之间的关系. 能描述的属性很多, 但是不是随便用的, 比如不能描述一个view的宽和另一个view的leading相等, iOS直接崩溃并告诉你这两个属性不能配对. 当你描述好了一个约束后, 你需要将其激活, 怎么激活? UIView有一个addConstraint的方法, 需要你自己添加. 那么该让谁来add呢? 经过一些测试发现, 这个调用add的view必须是约束中两个view的公共父view, 不一定是最低的那个, 只要是公共父view即可. 但是建议添加在最低公共父view中. 如果不想要一个约束了怎么办? UIView也有removeConstraint的方法, 去掉你不想要的即可.&lt;/p&gt;
&lt;h2 id=&quot;开始吐槽&quot;&gt;&lt;a href=&quot;#开始吐槽&quot; class=&quot;headerlink&quot; title=&quot;开始吐槽&quot;&gt;&lt;/a&gt;开始吐槽&lt;/h2&gt;&lt;p&gt;然后我要开始吐槽了. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;激活的问题.
 这算什么? 我自己去找公共父view? kidding me? 这个过程明显可以自动搞定啊. 然后发现iOS8支持了新的API. NSLayoutConstraint中多了一个active属性, 设置为YES即激活, NO即干掉. 但是对于iOS7及以下系统仍然需要自己找view去add和remove.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSLayoutConstraint类方法创建约束
NSLayoutConstraint有一个类方法用于创建一个约束, 这个方法有7个参数. 这7个参数不包含priority, 如果要设置要优先级还需要在创建约束后修改. 这个方法写起来简直就是屏幕杀手, 如果要规范一点一个参数一行,那么就是7行, 多写几个就轻松过一屏. 如果不折行, 那堆在一起的代码简直让人受不了. 那真是一坨一坨的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;VFL
也许苹果也觉得用一个带7个参数的方法去创建1个约束的方式有点儿不那么美观和方便, 于是开发了Visual Format Language, 目的是为了帮助开发者快速创建约束. 但是问题是, 这真的有效么? 使用VFL能一次性在一个方向上创建多个约束, 然后返回一个数组. 但是, 如果我需要根据需求调整其中一个约束呢? 我怎么获取到我想要的那个约束? 很遗憾, 你必须把VFL拆散, 对于你要的那一个约束, 要么你用NSLayoutConstraint的类方法去创建, 要么你用VFL去描述你要的那一个约束, 然后数组里面应该就只有那一个你要的约束了.
另外一点, 用VFL要注意的就是metrics和views两个字典, 一个是记录format里面的各种标量, 另一个记录出现在format里面的view, 也挺麻烦的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动画
貌似苹果还没有想好怎么比较方便地将约束和动画结合起来. 每次想动画呈现约束的变化, 都需要先改constant, 然后单独写一个动画, 在block里面找到一个view调用layoutIfNeeded. ╮(╯▽╰)╭, 为什么就不能稍微方便一点, 在animation的block里面修改约束就自动动画搞起呢? 技术上完全可行的说, 因为修改frame, alpha这些参数都是OK的.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;吐槽的基本上都是代码中编写AutoLayout相关代码的部分, 实际项目中也确实有不少需求是需要比较动态的布局的. 如果app比较简单, 使用storyboard就能完成布局描述的话就最好了, 那样将省掉非常多的编辑和调试约束的时间, 并且以后的维护也相对方便.&lt;/p&gt;
&lt;h2 id=&quot;总结-4&quot;&gt;&lt;a href=&quot;#总结-4&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;AutoLayout整体很强大, 而且在iOS环境中很有必要. 现在已经有多种尺寸的设备了, 使用AutoLayout会大大减少开发者适配的工作, 是时候了骚年.&lt;/p&gt;
&lt;p&gt;另外, 本人开发了一个用于简化代码编写AutoLayout约束的小库 &lt;a href=&quot;https://github.com/kaizeiyimi/XLYAutoLayoutEasy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XLYAutoLayoutEasy&lt;/a&gt;, 个人感觉更具有可读性和可维护性, 还支持swift哦.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;突然有一天, 苹果还在ios6的时候, 它发布了新的布局方式, 取名叫&lt;strong&gt;AutoLayout&lt;/strong&gt;, 听着很高大上--自动布局. 但是我这篇文章除了简单介绍一下它以外更多的是要吐槽的, 其实也就稍微吐一点点它的使用问题.&lt;/p&gt;
&lt;h2 id=&quot;A
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS present 场景切换的演化和要点</title>
    <link href="/2014/10/14/iOS_present_introduce_and_points/"/>
    <id>/2014/10/14/iOS_present_introduce_and_points/</id>
    <published>2014-10-14T06:30:00.000Z</published>
    <updated>2016-04-04T10:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS中的场景切换有多种方式, container内部的切换有UINavigationController的push pop操作, UITabbarController的tab切换. 外部的转换有popover(iPad专用), 和非常常用的present. 当然, UISplitViewController的replace在storyboard也被认为是一种切换(iPad专用, too). 本文将讨论present在不同版本的iOS SDK中的变化以及present的一些需要注意的问题. 本文的测试和讲述都是在xcode6.0.1中使用SDK8版本.&lt;/p&gt;
&lt;p&gt;present是在app中可以帮助用户理解app行为, 划分app功能模块, 是一种极其常用的场景切换方式. 最常用的方式就是:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[ViewControllerA presentViewController:ViewControllerB animated:&lt;span class=&quot;hljs-literal&quot;&gt;YES&lt;/span&gt; completion:&lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用后会在A的上方展示B, 用户需要在B中进行一些操作才能会能回到A, 在B展示的期间, A不能直接与用户交互.&lt;/p&gt;
&lt;h2 id=&quot;segue-from-iOS5&quot;&gt;&lt;a href=&quot;#segue-from-iOS5&quot; class=&quot;headerlink&quot; title=&quot;segue from iOS5&quot;&gt;&lt;/a&gt;segue from iOS5&lt;/h2&gt;&lt;p&gt;在很久以前, present能够定制的地方很少, 展示的方式在iPhone尺寸上只能全屏, iPad有formSheet等可以进行非全屏的展示. 而动画则只能在4个默认设置中选择(直上直下, 反转, 翻页, 淡入淡出). iOS5开始提供了segue来抽象一个跳转, 可以创建自定义的segue去做动画, 但是这样的做法会导致场景切换的动画和切换的逻辑过程是分离的, viewWillAppear和viewDidAppear的调用时机是不正确的. 简单来说就是用动画模拟了切换的过程, 但其实切换是一瞬间, 一般实现是在动画结束的completion里面调用无动画的present. 先看看苹果给出的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;- (&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)perform
{
&lt;span class=&quot;hljs-comment&quot;&gt;// Add your own animation code here.&lt;/span&gt;
    [[&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt; sourceViewController] presentModalViewController:[&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt; destinationViewController] animated:&lt;span class=&quot;hljs-literal&quot;&gt;NO&lt;/span&gt;];
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果按照苹果文档上给的代码去填上动画,  比如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;- (&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)perform
{
    &lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; *toView = [&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.destinationViewController view];
    &lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; *sourceView = [&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.sourceViewController view];
    &lt;span class=&quot;hljs-comment&quot;&gt;//寻找一个临时的view作为superview, 否则没有动画效果, 因为view不在window上&lt;/span&gt;
    [sourceView.superview addSubview:toView];
    toView.transform = &lt;span class=&quot;hljs-built_in&quot;&gt;CGAffineTransformMakeScale&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt;);
    [&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; animateWithDuration:&lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt; animations:^{
        toView.transform = &lt;span class=&quot;hljs-built_in&quot;&gt;CGAffineTransformIdentity&lt;/span&gt;;
    } completion:^{&lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt;}];
    [&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.sourceViewController presentViewController:&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.destinationViewController animated:&lt;span class=&quot;hljs-literal&quot;&gt;NO&lt;/span&gt; completion:&lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;];
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很不幸, 这个逻辑是有问题的. 问题就在addSubview那里. 为了做动画, view需要在window上, 而addSubview的时候toView进入window, 然后viewWillAppear和viewDidAppear就会立即被调用, 这中调用时机是不对的. 然后下面又立即做了present, SDK8中会得到这样一个warning: &lt;code&gt;Unbalanced calls to begin/end appearance transitions for &amp;lt;YourViewController: 0x7fc46bd7e860&amp;gt;.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果把present的语句放到动画的completion中, 没有warning, 但是viewWillAppear和viewDidAppear会在addSubview处连续调用一次, 然后动画结束时调用present又被连续调用一次, 导致各被调用两次. 注意这里&lt;strong&gt;不会&lt;/strong&gt;调用disappear相关的两个生命周期方法. 是不是很无语? 而如果去掉addSubview的调用, 将没有动画效果.&lt;/p&gt;
&lt;p&gt;网上有一些帖子里面的方法会在completion中, 在present之前多一个&lt;code&gt;[toView removeFromSuperview]&lt;/code&gt;的调用. 很不幸, 这样带来的问题更多了, 在SDK8中,会得到willAppear, didAppear, 动画结束时得到willDisappear, willAppear, 没有didAppear! 然后又得到前文提到的warning. 这真是让人沮丧的事情.&lt;/p&gt;
&lt;p&gt;所以我的建议是不要使用自定义的segue, viewController的生命周期完全得不到保障. 使用segue去模拟的方式会导致生命周期方法的调用和视觉过程不一致. 导致开发者在不同生命周期里配置的不同的逻辑的执行顺序和时机都不正确.&lt;/p&gt;
&lt;h2 id=&quot;Transitioning-from-iOS7&quot;&gt;&lt;a href=&quot;#Transitioning-from-iOS7&quot; class=&quot;headerlink&quot; title=&quot;Transitioning from iOS7&quot;&gt;&lt;/a&gt;Transitioning from iOS7&lt;/h2&gt;&lt;p&gt;一个真正的场景切换对于目标viewController来讲应该是viewWillAppear, 然后动画, 然后才是viewDidAppear.  iOS7中提供了transition的概念, 用于给场景切换提供自定义动画. 这套机制把场景切换的过程进行了拆分, 将其中的动画部分交由开发者提供, present调用还和以前一样, 也仍然可以使用系统提供的segue(系统内部是正确的, 只是开发者没有办法), 只是在真正开始present流程前设置一下presentedViewController.transitioningDelegate = someDelegate. 这样保证了viewController切换时的生命周期调用时机, 而且也可以创造出各种各样的动画效果. 简单看看使用方式:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;- (&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)prepareForSegue:(&lt;span class=&quot;hljs-built_in&quot;&gt;UIStoryboardSegue&lt;/span&gt; *)segue sender:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)sender
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (![segue.identifier isEqualToString:&lt;span class=&quot;hljs-string&quot;&gt;@&quot;your present segue identifier&quot;&lt;/span&gt;]) {
        &lt;span class=&quot;hljs-built_in&quot;&gt;UIViewController&lt;/span&gt; *viewController = segue.destinationViewController;
        viewController.transitioningDelegate = someDelegate;        
        &lt;span class=&quot;hljs-comment&quot;&gt;//文档要求设置为custom才会根据delegate去获取自定义动画,实际测试结果是不需要设置也OK. 而且设置了反而会在ios8中产生另外的问题, 后文描述&lt;/span&gt;
        viewController.modalPresentationStyle = &lt;span class=&quot;hljs-built_in&quot;&gt;UIModalPresentationCustom&lt;/span&gt;;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;苹果的文档说明:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Discussion
  When this view controller’s &lt;em&gt;modalPresentationStyle&lt;/em&gt; property is &lt;em&gt;UIModalPresentationCustom&lt;/em&gt;, UIKit uses the object in this property to retrieve the objects needed to present this view controller onscreen. The transitioning delegate must conform to the &lt;em&gt;UIViewControllerTransitioningDelegate&lt;/em&gt; protocol. Its job is to vend the animator objects used to animate this view controller’s view onscreen &lt;strong&gt;and an optional presentation controller to provide any additional chrome and animations&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加粗的是ios8才有的. 下面是someDelegate实现的方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;- (&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewControllerAnimatedTransitioning&lt;/span&gt;&amp;gt;)animationControllerForPresentedController:(&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewController&lt;/span&gt; *)presented presentingController:(&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewController&lt;/span&gt; *)presenting sourceController:(&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewController&lt;/span&gt; *)source
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [CustomPresentAnimation new];
}

- (&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewControllerAnimatedTransitioning&lt;/span&gt;&amp;gt;)animationControllerForDismissedController:(&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewController&lt;/span&gt; *)dismissed
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [CustomDismissAnimation new];
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里只是简单列举一下方法, 使用的动画对象没有自定义的属性因此就直接new了. 动画对象需要实现&lt;em&gt;UIViewControllerAnimatedTransitioning&lt;/em&gt; 或者 &lt;em&gt;UIViewControllerInteractiveTransitioning&lt;/em&gt; 协议, 后者从名字上能看出来是交互式切换. 从屏幕左边往右滑动去触发pop操作, 并且让UI跟随手指运动的切换方式就是交互式的.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;- (&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)animateTransition:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewControllerContextTransitioning&lt;/span&gt;&amp;gt;)transitionContext
{
    &lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; *containerView = [transitionContext containerView];
    &lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; *fromView = [transitionContext viewForKey:&lt;span class=&quot;hljs-built_in&quot;&gt;UITransitionContextFromViewKey&lt;/span&gt;];
    &lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; *toView = [transitionContext viewForKey:&lt;span class=&quot;hljs-built_in&quot;&gt;UITransitionContextToViewKey&lt;/span&gt;];
    [containerView insertSubview:toView atIndex:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];
    toView.alpha = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
    [&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; animateWithDuration:[&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt; transitionDuration:transitionContext] animations:^{
        fromView.transform = &lt;span class=&quot;hljs-built_in&quot;&gt;CGAffineTransformMakeScale&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1.5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1.5&lt;/span&gt;);
        fromView.alpha = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        toView.alpha = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
    } completion:^(&lt;span class=&quot;hljs-built_in&quot;&gt;BOOL&lt;/span&gt; finished) {
        [transitionContext completeTransition:&lt;span class=&quot;hljs-literal&quot;&gt;YES&lt;/span&gt;];
    }];
}

- (&lt;span class=&quot;hljs-built_in&quot;&gt;NSTimeInterval&lt;/span&gt;)transitionDuration:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewControllerContextTransitioning&lt;/span&gt;&amp;gt;)transitionContext
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这段代码对于present或者dismiss都可以使用, 效果就是当前fromView会变大并变透明, toView会从透明到完全不透明. 更深入的用法以及交互式动画的控制这里不讨论, 苹果的文档和示例代码都有很好的说明. &lt;/p&gt;
&lt;p&gt;关于是否设置&lt;em&gt;UIModalPresentationCustom&lt;/em&gt;的问题, 虽然文档要求设置, 但是测试是不需要. 如果设置了delegate并且使用&lt;em&gt;UIModalPresentationCurrentContext&lt;/em&gt;, 会达到currentContext起作用并且自定义动画也起作用的现象. 算bug么? (关于currentContext的使用后文有介绍)&lt;/p&gt;
&lt;p&gt;尽管在iOS7中开放了场景切换的动画控制, 对于present的一些需求仍然没有达到. 举一个简单的例子: 我不想在present调用后将presenter的View从window上移除, 因为我需要它作为一个背景, 就像iPad上的formSheet一样. 但是很遗憾, iPhone上不可以, presentingViewController的view会被移除, 当然你可以截屏, 但是无法同步内容了, 或者, 可以创建一个window, 指定一个相对较高的windowLevel, 将presentedController放到新的window中来达到需求(这也是我现在的做法...). 但是用window的麻烦就是不容易控制, app中其他的部分和这个viewController只有数据交互, viewController和view的层级结构被完全剥离了. 不是很好的解决方法.&lt;/p&gt;
&lt;h2 id=&quot;UIPresentation-from-iOS8&quot;&gt;&lt;a href=&quot;#UIPresentation-from-iOS8&quot; class=&quot;headerlink&quot; title=&quot;UIPresentation from iOS8&quot;&gt;&lt;/a&gt;UIPresentation from iOS8&lt;/h2&gt;&lt;h3 id=&quot;UIPresentationController&quot;&gt;&lt;a href=&quot;#UIPresentationController&quot; class=&quot;headerlink&quot; title=&quot;UIPresentationController&quot;&gt;&lt;/a&gt;UIPresentationController&lt;/h3&gt;&lt;p&gt;iOS8中再次强化了present的使用. 普通的使用当然没有问题, 但是如果想更好地控制present的过程和细节, 那么iOS8中的UIPresentationController就是完成这个任务的. 它描述的是一个present从开始到结束的全过程, 这里不包含如何做过场动画, 但是有方法可以同其&lt;strong&gt;交流&lt;/strong&gt;(后文会解释), 过场动画仍然由iOS7的方式来控制. 从开始到结束是一个怎样的过程? 是从某一个viewcontroller调用present开始, 一直到dismiss掉被展示的presentedViewController. 期间的大小变化, 布局等都属于这个过程的一部分. UIPresentationController提供的信息很多, 如:正在展示的和被展示的viewController, 展示的方式, 场景切换时的containerView, 然后是一些方法提供诸如是否需要移除presentingView, 是否全屏展示, 还有布局相关的一些回调和方法. 详细的内容和用法这里不赘述了, 可以看头文件以了解更多, 另一篇博客中会单独介绍.&lt;/p&gt;
&lt;p&gt;要想使用UIPresentationController去控制present过程, 就需要将presentedViewController的&lt;em&gt;modalPresentationStyle&lt;/em&gt; 设置为 &lt;em&gt;UIModalPresentationCustom&lt;/em&gt;, 否则将不会尝试获取UIPresentationController的实例. 而是否有presentationController来控制present过程得到的效果也不一样, 最明显的一个就是默认不移除presenter的view. 只需要设置为&lt;em&gt;UIModalPresentationCustom&lt;/em&gt;, 不需要设置transitionDelegate就可以看到效果. 但是如果不设置transitionDelegate而跑在ios7的设备中会得到如下warning: &lt;em&gt;UIModalPresentationCustom presentation style can only be used with an animator or with unanimated presentations.&lt;/em&gt;  如果设置了delegate, 可以多实现一个方法去返回自定义的presentationController, 可以定制特别多的细节, 比如chrome和content的大小, 场景切换相关的附加动画. &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; *dimView = [[&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; alloc] initWithFrame:&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.containerView.bounds];
    dimView.backgroundColor = [&lt;span class=&quot;hljs-built_in&quot;&gt;UIColor&lt;/span&gt; colorWithRed:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; green:&lt;span class=&quot;hljs-number&quot;&gt;170&lt;/span&gt; blue:&lt;span class=&quot;hljs-number&quot;&gt;170&lt;/span&gt; alpha:&lt;span class=&quot;hljs-number&quot;&gt;0.8&lt;/span&gt;];
    dimView.alpha = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
    dimView.autoresizingMask = &lt;span class=&quot;hljs-built_in&quot;&gt;UIViewAutoresizingFlexibleWidth&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;UIViewAutoresizingFlexibleHeight&lt;/span&gt;;
    [&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.containerView insertSubview:dimView atIndex:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];

[&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.presentedViewController.transitionCoordinator animateAlongsideTransition:^(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewControllerTransitionCoordinatorContext&lt;/span&gt;&amp;gt; context) {
        dimView.alpha = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
    } completion:&lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;iPad上formSheet弹出时周围不是变黑么? 这里的代码就是变成天蓝色. 注意那个animateAlongSideTransition方法, 这个方法的意思是block里地动画是和过场动画一起执行的, 测试了一下, 效果或者说实际做法就是把这个block加到了过场动画的block后面后组成一个新的block来做动画, 这就是前文所述的&amp;quot;交流&amp;quot;. 开发中我有时候也会这样提供一些回调和设置来解决一些动画的同步问题. 还有一些关于size控制的就不多说了.&lt;/p&gt;
&lt;p&gt; 除了开发者可以定制present过程, 苹果自己也对系统控件做了很多改造. UIPresentationController是一个父类, iOS自己实现了一些子类如私有的全屏展示Controller还有UIPopoverPresentationController, 而且将很多以前的控件进行了改造, UIAlertView, UIActionSheet, popover, searchDisplayController都被改造了. 苹果的工程师应该是这么认为的: 这些东西都是在现有的viewController上展示一些新的内容, 认为他们的行为其实就是present. 因此从iOS8开始我们多了UIAlertController来包含alert和actionSheet的展示, 并且是基于block的. popover不是提供新的viewController, 而是提供了一种展示方式&lt;code&gt;UIModalPresentationPopover&lt;/code&gt; 以及 UIPopoverPresentationController来提供管理,  UISearchDisplayController被替换为UISearchController.(wwdc的视频里面, 工程师自喷了一下以前使用的是view, 通过addsubview去添加, 却要装得好像一个viewController, 说是付出了很多, 回报很少的样子...).&lt;/p&gt;
&lt;p&gt;看苹果的意思是要用viewController来区分所有的场景, 并用presentation来管理场景切换(不包含容器内部的切换). 以前的alert和actionSheet的自己创建window, 以及UISearchDisplayController去addsubview的方式被否定了. 的确这是很不好的, 就拿UIAlertView来说, 因其自己处在一个独立的window中, 如果调用show的viewController消失了, 却没有设置alertView消失, 就会导致一个很尴尬的现象, 内容都没了, 你alert个啥呢? 而且, 如果alertView的delegate正好是这个viewController的话, 点击alertView的按钮还会导致崩溃, 因为delegate属性是assign不是weak (要注意, assign是正确的设计). 当然可以在viewController的viewWillDisappear或者dealloc等地方添加一下干掉alertView的逻辑, 但是这样就会给viewController添加变量了, 并且有时候会添加很多... 对于UIAlertView, 系统还有一个行为比较有意思, alertView可以在上一个没有消失的情况下继续弹出, 弹出时会暂时隐藏上一个, 待这一个处理完毕后再重新显示. 在弹窗正在展示的期间如果app切到后台, 再切回前台, alertView会重新从无到有的展示一次. 而换成alertController以后, 展示的其实就是一个看起来跟alertView一样的viewController, 系统是不允许一个presentingViewController同时present两个viewController的, 因此alertView的那种允许连续弹多个alert的有趣的现象没有了, 并且也不会在前后台切换时出现前述的重新展示的现象. 如果有人以前依赖了这些逻辑就一定要小心了, UIAlertController需要依赖一个viewController才能进行展示, 不能自行创建window进行展示. 也就不存在缓存之前的alert一说了.&lt;/p&gt;
&lt;h3 id=&quot;adaptive-自适应&quot;&gt;&lt;a href=&quot;#adaptive-自适应&quot; class=&quot;headerlink&quot; title=&quot;adaptive 自适应&quot;&gt;&lt;/a&gt;adaptive 自适应&lt;/h3&gt;&lt;p&gt;这里补充说一点adaptive. 苹果对iOS8中所作的present的改动和自适应不同屏幕尺寸是有非常大关系的. 为什么允许在iPhone环境中也能使用popover和split? 其实在启用size classes后, 苹果期望开发者能更多地关注现在的尺寸中宽度和高度有没有被压缩,  &lt;em&gt;UITraitCollection&lt;/em&gt; 描述了现在所处的环境, 包含宽度, 高度的情况, 屏幕的scale, 设备.(更多地细节看wwdc视频和文档). 在有size classes的情况下, 拿popover来举例, 同一段代码就可能允许于不同尺寸的设备中, iPad中宽度和高度都是正常, 能像期望地那样弹出popover, 效果不变. 而在iPhone中也就是宽度或者高度被压缩时, popover不能展示, 系统的UIPopoverPresentationController的默认行为是帮你改成全屏present. 如果你想再稍微定制下全屏展示时的样式比如添加一个navigationController来包含将要展示的viewController, 那么可以实现UIPresentationController的代理方法来提供调整:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//viewController中&lt;/span&gt;
- (&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)prepareForSegue:(&lt;span class=&quot;hljs-built_in&quot;&gt;UIStoryboardSegue&lt;/span&gt; *)segue sender:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)sender
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ([segue.identifier isEqualToString:&lt;span class=&quot;hljs-string&quot;&gt;@&quot;popover&quot;&lt;/span&gt;]) {
        &lt;span class=&quot;hljs-built_in&quot;&gt;UIViewController&lt;/span&gt; *viewController = segue.destinationViewController;
        viewController.presentationController.delegate = &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;;
    }
}

&lt;span class=&quot;hljs-comment&quot;&gt;//代理方法&lt;/span&gt;
- (&lt;span class=&quot;hljs-built_in&quot;&gt;UIModalPresentationStyle&lt;/span&gt;)adaptivePresentationStyleForPresentationController:(&lt;span class=&quot;hljs-built_in&quot;&gt;UIPresentationController&lt;/span&gt; *)controller
{
&lt;span class=&quot;hljs-comment&quot;&gt;//系统默认的应该是UIModalPresentationFullScreen, 没有over这个单词&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;UIModalPresentationOverFullScreen&lt;/span&gt;;
}

&lt;span class=&quot;hljs-comment&quot;&gt;//must implement the above one to give a chance to call this one...&lt;/span&gt;
- (&lt;span class=&quot;hljs-built_in&quot;&gt;UIViewController&lt;/span&gt; *)presentationController:(&lt;span class=&quot;hljs-built_in&quot;&gt;UIPresentationController&lt;/span&gt; *)controller viewControllerForAdaptivePresentationStyle:(&lt;span class=&quot;hljs-built_in&quot;&gt;UIModalPresentationStyle&lt;/span&gt;)style
{
    &lt;span class=&quot;hljs-built_in&quot;&gt;UINavigationController&lt;/span&gt; *navVC = [[&lt;span class=&quot;hljs-built_in&quot;&gt;UINavigationController&lt;/span&gt; alloc] initWithRootViewController:controller.presentedViewController];
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; navVC;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果不实现第一个方法的话就不会调用第二个代理方法, 虽然默认的也是全屏, 而且你只能返回全屏(有两个值都可以). 然后也要注意: &lt;strong&gt;如果没有使用size classes, 只保留iPhone size时, 第一个代理方法返回UIModalPresentationFullScreen, 则不会调用第二个代理方法. 需要返回UIModalPresentationOverFullScreen才行&lt;/strong&gt;. 某种程度上可以认为是个小bug. 不过带over的变量是iOS8才有的, 理论上也应该使用新的变量才对. &lt;/p&gt;
&lt;p&gt;另外可以强制不使用adaptive, 只需要返回UIModalPresentationNone即可. 在压缩的空间内也可以展示为popover. 这点很好~&lt;/p&gt;
&lt;h1 id=&quot;Present-的一些要点&quot;&gt;&lt;a href=&quot;#Present-的一些要点&quot; class=&quot;headerlink&quot; title=&quot;Present 的一些要点&quot;&gt;&lt;/a&gt;Present 的一些要点&lt;/h1&gt;&lt;p&gt;前面说了很多present的演化, 从segue到transition再到presentationController, 都是在加强present, 试图给开发者更多的空间. 下面说一些present的要点, 主要说一下present中viewController的层级结构以及如何修改确定层级关系.&lt;/p&gt;
&lt;p&gt;当一个app运行起来, window上有一个rootViewController, 可能是一个NavigationController或者一个TabbarController, 我们可以进行push操作深入到一个ChildViewController中, 假如A-&amp;gt;B-&amp;gt;C, A是navigationController, push进入到C. 这时候我们在C上有一个需求需要present展示D. 这个过程需要知道一些viewController才能真正开始. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;presentingViewController: 这个present到底是谁在做支持?&lt;/li&gt;
&lt;li&gt;presentedViewController: 这个present中被展示的是谁?&lt;/li&gt;
&lt;li&gt;sourceViewController: 这个present是谁发起的?
要注意, source和presenting往往是不一样的. 在本例中, A最终会成为presenting, C是source, 而D是presented. 表示如下:&lt;pre&gt;
D
|
A-&gt;B-&gt;C
&lt;/pre&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;D现在是和A进行了关联, 形成了presenting和presented的关系. viewController有两个readOnly的属性, 分别是presentingViewController和presentedViewController. 前者是指当前viewController正在被谁展示, 后者是指正在被当前viewController展示的是谁. 这两个属性其实是计算属性, 他们都是递归往parent寻找, 直到找到真正在做present的viewController. 本例中在C的presentingViewController为nil, presentedViewController为D. 这个结果对于A, B, C都是一样的, 因为B和C都是A的childViewController. D的presentingViewcontroller则是A, presentedViewController是nil. 如果D也是一个容器, 假如仍然是navigationController, 那么D也push到E.&lt;/p&gt;
&lt;pre&gt;
D-&gt;E
|
A-&gt;B-&gt;C
&lt;/pre&gt;
A, B, C, D的那两个属性的值都没有变化, E的presentingViewController是A, presentedViewController是nil. 我们可以在E上继续present到F, F再push到G.
&lt;pre&gt;
F-&gt;G
|
D-&gt;E
|
A-&gt;B-&gt;C
&lt;/pre&gt;

&lt;p&gt;这是D的presentedViewController就是F. 其余值也能响应推断出来. &lt;/p&gt;
&lt;p&gt;从另外一个方式来理解, present意味着展示新的模块, 新模块应该在逻辑上是另外一层, 默认情况下, present新的一层由当前层的根元素来操作. 所以是A展示了D, D展示了F. 为什么说是默认情况?  因为viewController还有一个属性:&lt;em&gt;definesPresentationContext&lt;/em&gt;. 默认值为NO. 文档中描述如果值为YES, 意味着期望presentedViewController覆盖当前的view的范围. 直观地来讲, 就是viewController告诉系统, 当我或者我的childViewController做present时, presenting是我, 覆盖我的显示范围. 如果真的想要这样的效果, 还需要给presentedViewController设置&lt;em&gt;modalPresentationStyle&lt;/em&gt;的值为&lt;em&gt;UIModalPresentationCurrentContext&lt;/em&gt;, 指定presentedViewController在展示时使用当前的上下文. &lt;/p&gt;
&lt;p&gt;如果两个值都正确设置了, 当一个childViewController调用present时, 它首先检查自己, 然后递归检查parentViewController是否有谁的&lt;em&gt;definesPresentationContext&lt;/em&gt;是YES. 这样会找到一个viewController来作为presenting, 然后present就是在这个viewController上做. 注意, 它有可能不是当前层的根, 也就意味着根仍然可以present. 根present的viewController的层级在child之上. &lt;/p&gt;
&lt;p&gt;如果没有同时达成上述的两个变量设置, 得到的结果就是默认由当前层的根进行present, 并且不以根的显示范围做控制. 这里有一个需要注意的: 如果在一个viewController (X)上设定了&lt;em&gt;definesPresentationContext&lt;/em&gt;为YES, 并且presentedViewController (Y)设置了&lt;em&gt;modalPresentationStyle&lt;/em&gt;为&lt;em&gt;UIModalPresentationCurrentContext&lt;/em&gt;, 在Y上再次进行present时,  下一个presentedViewController (Z)&lt;strong&gt;没有设置&lt;/strong&gt; 为&lt;em&gt;UIModalPresentationCurrentContext&lt;/em&gt;的话, 展示会变成全屏, 此时的Z的presentingViewController变成了X. 更奇怪的是绑定的unwindSegue会莫名失效, 其它事件还能正确响应. 如果Z设置了&lt;em&gt;UIModalPresentationCurrentContext&lt;/em&gt;, 则present覆盖的还是X的范围, presentingViewController属性指向的是Y.&lt;/p&gt;
&lt;h2 id=&quot;总结-2&quot;&gt;&lt;a href=&quot;#总结-2&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;很乱有木有? 我也觉得很乱. 但事实就是这样. 苹果这次的iOS8升级带来的问题不少, 添加了size class来描述用户界面的变化, 顺便一提, 因为引入size class的概念, 转屏的方法也全部废弃, 改为响应尺寸的变化. 引入UIPresentationController进行present管理, 系统控件的展示也基本上都变成了present展示, 行为发生了大幅变化. &lt;em&gt;UIModalPresentationCustom&lt;/em&gt;的设置与否会导致不同的结果. 允许adaptive特性来调整不同尺寸下地显示策略, 但是不兼容iOS7及以前的系统, 基本上都是些新的API和设计. &lt;/p&gt;
&lt;p&gt;稍微吐槽下: autoLayout的使用仍然有些问题, 有些设置不是在所有版本中都支持的, 虽然给出了warning, 但是没有建议如何修改. 使用autoLayout后的动画也有各种各样的问题, 给使用了autolayout的viewController做过场动画, 改变view的transform来完成效果. 如果使用currentContext的方式present 并且最终显示范围和viewController的初始大小不一致时, 会看到很好玩的结果. 动画效果完全就是打脸. 也尝试过给animation加上layoutSubViews的option, 然后又得到了另外一个打脸的动画效果. 分析了一下代码, 发现上述的改动总结起来就是先改动了transform让其缩放变小, 然后动画block中重设transform, 然后改变view的frame. 是的, 就是因为改变了frame导致了各种奇葩的效果, 有兴趣的自己试试就知道了. 还有很多其他的问题这篇博客就不在吐槽了, 再写就太长了.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS中的场景切换有多种方式, container内部的切换有UINavigationController的push pop操作, UITabbarController的tab切换. 外部的转换有popover(iPad专用), 和非常常用的present. 当然, UIS
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>XLYMultiCastDelegate 多播代理</title>
    <link href="/2014/10/10/XLYMultiCastDelegate/"/>
    <id>/2014/10/10/XLYMultiCastDelegate/</id>
    <published>2014-10-10T08:00:00.000Z</published>
    <updated>2016-04-04T10:12:18.000Z</updated>
    
    <content type="html">&lt;p&gt;通知中心NSNotificationCenter, 大家都知道怎么用. 需要add observer, 指定selector, 指定监听的通知(字符串), 在selector对应的方法中获取userInfo字典, 根据key获取value进行操作, 最后还得在某个时机remove observer. 虽然按照规范去编写代码不容易出错, 但是仍然有很多麻烦, selector的使用错误不容易在编译时检查, 通知和userInfo都是使用字符串, 需要大量定义和维护字符串常量. 这点有时候着实会让人很烦恼. 本文介绍一种利用&lt;strong&gt;消息转发&lt;/strong&gt;和&lt;strong&gt;代理&lt;/strong&gt;来做广播的想法.&lt;/p&gt;
&lt;p&gt;记得做第一个项目时(一年多前...), 需要做聊天, 当时因为很多原因没有重新开发, 而是使用了之前项目的聊天模块代码, 结构十分混乱, 大量的使用了Notification并且很多地方的用法是错误的. 虽然开发得很不爽, 总之是硬扛下去了, 不堪回首. 期间积累了一些想法, 也写过一些demo验证了一些, 其中一个就是本文介绍的&lt;code&gt;MultiCastDelegate&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;我们遇到了一类问题, 当某个数据发生变化时, 可能有多个对象期望得到通知, 但是各自所处的线程或者Queue是不一样的. NSNotificationCenter除了在发送通知时的一些常量定义的问题外还有一个重要的特性: 通知的调用是在postNotification的调用线程中同步执行. 如果我们有主线程和后台的对象同时监听通知, NSNotificationCenter就无法满足需求了, 总是至少有一个observer不是在自己所属的线程或者Queue调起. 难道还要自己再次dispatch一下?&lt;/p&gt;
&lt;h2 id=&quot;XLYMultiCastDelegate&quot;&gt;&lt;a href=&quot;#XLYMultiCastDelegate&quot; class=&quot;headerlink&quot; title=&quot;XLYMultiCastDelegate&quot;&gt;&lt;/a&gt;XLYMultiCastDelegate&lt;/h2&gt;&lt;h3 id=&quot;使用简介&quot;&gt;&lt;a href=&quot;#使用简介&quot; class=&quot;headerlink&quot; title=&quot;使用简介&quot;&gt;&lt;/a&gt;使用简介&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/kaizeiyimi/XLYMultiCastDelegate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XLYMultiCastDelegate&lt;/a&gt;&lt;/strong&gt;来拯救你. 它的中文名字叫多播代理? 其实是广播. 它的作用跟通知中心NSNotificationCenter很像, 要做的事情也是一对多的通知. 实现的思路严重依赖Objective-C的消息转发机制. 它不是完全的通知中心的代替实现, multiCastDelegate 其实需要使用一个protocol来初始化. 之后添加的observer或者说delegate必须要实现这个protocol, 否则将不能添加. 先看看基本使用, 再继续介绍.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;@protocol&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SimpleProtocol&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;NSObject&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;@optional&lt;/span&gt;
- (&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt;)someOptionalMethod;
&lt;span class=&quot;hljs-keyword&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;hljs-comment&quot;&gt;//创建&lt;/span&gt;
XLYMultiCastDelegate *multiDelegate = [[XLYMultiCastDelegate alloc] initWithConformingProtocol:&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;@protocol&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;SimpleProtocol&lt;/span&gt;)];&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;//添加代理&lt;/span&gt;
[multiDelegate addDelegate:&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt; dispatchQueue:dispatch_get_main_queue()];
&lt;span class=&quot;hljs-comment&quot;&gt;//需要有一个地方来保存multiCastDelegate实例&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.multiDelegate = (&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;&amp;lt;SimpleProtocol&amp;gt;)multiDelegate;
&lt;span class=&quot;hljs-comment&quot;&gt;//可以检查是否实现了协议&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;BOOL&lt;/span&gt; result = [&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.multiDelegate conformsToProtocol:&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;@protocol&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;SimpleProtocol&lt;/span&gt;)];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用其实很简单, 首先需要创建一个multiDelegate对象, SimpleProtocol真的很simple, 只有一个可选方法. 添加代理时可以指定dispatchQueue参数, 这个Queue将是代理方法被调起的Queue, 解决了通知中心不能往不同的线程或Queue发送通知的问题. 创建了multiDelegate对象当然需要找个地方存起来. 以后也可以随时添加或者移除delegate. 当然你可以检查multiDelegate是否实现了协议, 结果是YES.&lt;/p&gt;
&lt;h3 id=&quot;原理说明&quot;&gt;&lt;a href=&quot;#原理说明&quot; class=&quot;headerlink&quot; title=&quot;原理说明&quot;&gt;&lt;/a&gt;原理说明&lt;/h3&gt;&lt;p&gt;下面详细说明一下实现的细节和需要注意的问题, 会涉及到一些runtime的知识, 这里不做详细的介绍, 需要了解的请参阅&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果的文档&lt;/a&gt;. 这里先仅对OC环境进行说明, swift的后面单独说明.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;协议是一个&lt;code&gt;Protocol *&lt;/code&gt;类型. 代码中可以这样声明变量和获取协议:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//声明为property&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;strong&lt;/span&gt;) Protocol *protocol;

&lt;span class=&quot;hljs-comment&quot;&gt;//获取&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;NSString&lt;/span&gt; *protocolName = &lt;span class=&quot;hljs-string&quot;&gt;@&quot;SimpleProtocol&quot;&lt;/span&gt;;
Protocol *protocol = objc_getProtocol(protocolName.UTF8String);

&lt;span class=&quot;hljs-comment&quot;&gt;//或者&lt;/span&gt;
Protocol *protocol = &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;@protocol&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;SimpleProtocol&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们需要记录下当前多播代理所支持的协议, 协议在runtime环境里面应该是单例的形式存在的. 在添加新的delegate到多播代理中时进行的检查很简单 &lt;code&gt;[delegate conformsToProtocol:self.protocol]&lt;/code&gt;, 如果通过则允许添加. 内部会创建一个delegateNode对象来weak持有添加的delegate, 并记录对应的delegateQueue. 还有一些添加删除的管理delegate的方法就不多说, 都是些简单逻辑.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;runtime支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重写 &lt;code&gt;-[NSObject conformsToProtocol:]&lt;/code&gt;方法, 判定是否实现了某个协议. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重写 &lt;code&gt;-[NSObject respondsToSelector:]&lt;/code&gt;方法, 遍历现有的代理, 只要任何一个能够响应则认为能够响应.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重写 &lt;code&gt;-[NSObject methodSignatureForSelector:]&lt;/code&gt;方法, 详细文档说明参考apple的runtime文档, 我们这里的场景是multiDelegate自己不能响应方法调用, 因此需要做调用转发, 这个时候该方法会被调用来给&lt;code&gt;NSInvocation&lt;/code&gt;对象设置方法签名. 是为自己不能响应的方法寻找方法签名, 仍然遍历现有的代理, 找到一个正确地签名即可. 签名记录了这个方法的返回值类型, receiver的类型, 以及参数个数等信息. 如果没有delegate能够提供签名, 则默认提供doNothing的方法签名, 正如其名, 啥也不做, 只是为了不崩溃. 这个行为也可以理解为消息没有接受者则丢弃.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重写 &lt;code&gt;-[NSObject forwardInvocation:]&lt;/code&gt;方法, 这里就是最重要的地方. 当一个对象不能相应一个selector调用时, 满足一些条件的情况下最终会走到这里, 条件如何达成请参阅&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果文档&lt;/a&gt;, 当然我们这里是达成了, 现在我们得到了一个invocation对象, 它包含了方法签名, 参数等信息, 是对一个对象进行方法调用的一个封装. NSInvocation对象有一个方法&lt;code&gt;-[NSInvocation invokeWithTarget:]&lt;/code&gt;, 其作用就是将target作为方法调用的receiver进行调用, 参数不变. 所以我们将遍历所有的delegate, 并在它们的delegateQueue里面进行调用, 这样就完成了消息调用的转发.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;需要注意的问题&quot;&gt;&lt;a href=&quot;#需要注意的问题&quot; class=&quot;headerlink&quot; title=&quot;需要注意的问题&quot;&gt;&lt;/a&gt;需要注意的问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;创建XLYMultiCastDelegate实例, 添加移除delegate等管理操作都是线程不安全的, 需要使用者维护.&lt;/li&gt;
&lt;li&gt;本质上是想用代理方法调用来完成通知, 因此应该将其应用于没有返回值的代理方法. 如果一定要发送带返回值的方法调用, 内部逻辑会在发送调用的线程中同步寻找第一个能够响应此方法的delegate并调用. 这里不能使用dispatch_async, 必须同步调用, 否则调用者会立即得到nil的返回值.&lt;/li&gt;
&lt;li&gt;遍历delegate并进行方法调用的for循环使用了信号量来进行同步. Invocation不支持copy, 并且有一个问题: 如果在不同的线程同时对同一个invocation对象调用&lt;code&gt;-[NSInvocation invokeWithTarget:]&lt;/code&gt;, 可能会出错, 这个错误不是崩溃, 而是target的处理错误. 比如对A,B同时进行调用, invoke调用时应该会记录当前的receiver(根据结果现象推断的), 中间还会经过一些步骤才会真正发起调用, A先被记录, 在发起调用前, B又被记录, 则两次调用的结果会是调用了两次B. 因此需要同步一下, 保证invocation对象的串行使用.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;swift支持&quot;&gt;&lt;a href=&quot;#swift支持&quot; class=&quot;headerlink&quot; title=&quot;swift支持&quot;&gt;&lt;/a&gt;swift支持&lt;/h3&gt;&lt;p&gt;很不巧, 苹果发布的新的编程语言swift对runtime, KVO, KVC的支持很不友好. swift加入了模块的概念来解决OC多年的全局符号表的痛, 还有可选值什么的一些新概念. 其他的特性就是5仁月饼. 如果能够习惯OC中的block, 闭包, 那么swift里面的东西就没啥问题了, 都是些语言细节, 底层依然是runtime来支撑, 可以和OC混合编译. 细节请参阅&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;swift&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本来想直接用swift重新实现的, 结果被直接拒绝了. swift中不允许使用NSInvocation对象, 只能混编了. 获取协议对象时需要注意是否是swift中定义的协议:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//使用oc中定义的协议没有模块&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;XLYMultiCastDelegate&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(protocolName: &lt;span class=&quot;hljs-string&quot;&gt;&quot;SimpleProtocol&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;//使用 swift定义的协议需要加上模块信息, 否则无法获取&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;XLYMultiCastDelegate&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(protocolName: &lt;span class=&quot;hljs-string&quot;&gt;&quot;XLYMultiCastDelegateDemo.SimpleSwiftProtocol&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在调用时需要用as进行类型转换才能调用方法. &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;multiDelegate &lt;/span&gt;= &lt;span class=&quot;hljs-keyword&quot;&gt;multiDelegateUsingOCProtocol &lt;/span&gt;as SimpleProtocol&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行时会使用&lt;code&gt;-[NSObject respondsToSelector:]&lt;/code&gt;来进行检查是否可以转换. 转换成功后就可以进行调用了.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;multiDelegate&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.someOptionalMethod&lt;/span&gt;!()&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结-1&quot;&gt;&lt;a href=&quot;#总结-1&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;消息转发机制由语言支持, 应该是受到了smalltalk的影响, ruby也有类似的机制. swift想要做成一个类型安全的语言, 支持太多动态的特性会让很多东西失去保证. 总之, 工欲善其事, 必先利其器. 多了解一些语言的特性, 能够学到一些技术的设计思路, 还能帮助简化程序设计, 同时提高逼格😜.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;通知中心NSNotificationCenter, 大家都知道怎么用. 需要add observer, 指定selector, 指定监听的通知(字符串), 在selector对应的方法中获取userInfo字典, 根据key获取value进行操作, 最后还得在某个时机rem
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="GitHub" scheme="/tags/GitHub/"/>
    
  </entry>
  
</feed>
